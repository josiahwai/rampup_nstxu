function [response,eqx,misc] = gspert(eq,tok_data_struct,options,idoplots)
%
%  USAGE: [response,eqx,misc] = gspert(eq,tok_data_struct,options,idoplots)
%
%  PURPOSE: Calculate a plasma response with constraints on current
%           versus normalized area and thermal energy versus normalized volume
%
%  INPUTS:
%    eq = structure containing equilibrium information
%    tok_data_struct = toksys structure containing name, geometry, greens.
%    options = optional structure with the following optional fields:
%       options.iconstraints (default = 1) selects a set of parameters that will
%       independently affect the plasma. The choices are (Is=conductor currents):
%	  1. betap, li, Ip, Is.
%	  2. Wth, li, Ip, Is.
%         3. Wth(V/Vtot), I(A/Atot), Is
%       If options is not structure it will be interpreted as options.iconstraints
%       The behavior of profiles can be chosen with the following:
%       options.dIndbetap, dIndw = recommended scaling of I vs A/Atot with betap or Wth
%       options.dIndli = recommended scaling of I versus A/Atot with li
%       options.dIndip = recommended scaling of I versus A/Atot with Ip
%       options.dWndbetap, dWndw = recommended scaling of W vs V/Vtot with betap or Wth
%       options.dWndli = recommended scaling of W versus V/Vtot with li
%       options.dWndip = recommended scaling of W versus V/Vtot with Ip
%       Returned response differs if for instance dWndbetap renders dli~=0, dbetap~=1, dip~=0
%       options.q = q values for which to calculate contours and their responses
%       options.gapspec(ngap,1:6), gap specification = (r,z,gr,gz,rs,zs),
%         i.e. a point (r,z), a vector (gr,gz), and an optional separatrix point (rs,zs)
%         A gap is *defined* as length of vector (gr,gz) extending from (r,z) to separatrix
%         If gapspec=(0,0,0,0,rs,zs), (gr,gz) is set to grad psi and (r,z) to a limiter point.
%       options.iso(niso,1:2), isoflux point specification = (r,z)
%       options.iverbose = flag to select text messages:
%         2=verbosinator, 1=talk, 0=shut up (default), -1=don't even warn
%       options.itdinclude = flag to include TD (=3D) in the group S of conductors
%         the default is 0 which sets ntd=0
%       options.idxcc = indices of CC elements in eigenmode analysis (default=1:ncc)
%       options.idxvv = indices of VV elements in eigenmode analysis (default=1:nvv)
%       options.idxtd = indices of TD (3D) elements in eigenmode analysis (default=1:ntd)
%       options.iwait = error handling: 0 (default) = warn, 1 = wait with message
%       options.iframe4movie = flag to make jpegs of idoplots, 0 = don't (default)
%       options.gspertfigno = figure number for plots, (111 is the default)
%       options.what2plot = choose what to show in the contour plots:
%         1. Change of psizr (default)
%         2. Change of normalized psi, dpsi-psibar*dpsibry-(1-psibar)*dpsimag
%         3. Change of flux generated by plasma currents, dpsizr_pla
%         4. Change of current density on grid, dcphi/dr/dz
%       options.nkn = number of knots for spline functions. Overrides the automatic number.
%    idoplots = (optional) array of flags to plot responses to individual quantities.
%       if idoplots is scalar, the value will apply to all plots: default is 0=don't plot
%       When iconstraints=1 or 2 the indices of idoplots correspond to:
%       1=w or betap, 2=li, 3=Ip, 4=time (unstable mode),
%       4+(1:nss)=conductors, 4+nss+(1:nss)=eigen modes
%       When iconstraints=3 the indices of idoplots correspond to:
%       [1:nr] = W profile, nr+[1:nr] =I profile, 2*nr+4=time (unstable mode),
%       2*nr+4+(1:nss)=conductors, 4+nss+(1:nss)=eigen modes
%       0 means no plot, <0 means wait, >0 is time in seconds to pause.
%
%  OUTPUTS:
%    response = structure with responses.
%      Responses of the following quantities are provided:
%        current in grid cells (cphi),
%        current centroid (r,z),
%        boundary points (rb,zb) with touch or x-point as first element in the arrays,
%        all four possible strike points
%        axis and boundary flux, (psimag,psibry)
%        the functions pprime, ffprim,
%        the q-profile (qpsi),
%        contours of q = options.q (rq(nq,:), zq(nq,:)),
%        gap responses, how distance from (r,z) along (gr,gz) to separatrix changes
%        iso flux, br, bz responses
%        the geometric quantities L, A, V, I, W (explained below)
%      Here, the change of cphi, dcphi = sum(djphi*dr*dz)+dIedge
%      The responses are due to changes in these quantities:
%        coil and vessel currents (is),
%        total thermal energy (w) or betap or points on the profile W(V/Vtot),
%        li and total plasma current (ip) or points on the profile of I(A/Atot)
%      The efit definition of betap, li is used [Lao et al., Nucl. Fusion volume 25 (1985)]
%      In the case of qpsi and q-contours the response to Bphi (at eq.rzero) is added.
%      Response to time is also provided by:
%        Portone stability margin, growth rate and current vector (dIs) for unstable mode
%      points = indices to points on profiles of W(v), I(a) that are used as contraints
%    eqx = structure with extra equilibrium quantities derived from the equilibrium data:
%      (rcur, zcur), (ra, za), (r0, z0), (rx, zx), (rstrike, zstrike),
%        loci of current centroid, mag. axis, boundary defining point, x-points, strike points
%      drsep, distance between x-point flux surfaces measured in the outboard midplane
%      ilimited, a flag indicating if the plasma is limited, otherwise it is diverted
%      Rcnt(1:na,1:nr), Zcnt(1:na,1:nr), flux contours 
%      L(1:nr), surface integral of 1/R enclosed by flux contours
%      A(1:nr), area enclosed by flux contours
%      V(1:nr), volume enclosed by flux contours
%      I(1:nr), current enclosed by flux contours
%      W(1:nr), thermal energy enclosed by flux contours
%      betap = 4/3*mu0*W(end)/V(end)/bp2flx (should agree well with efit value)
%      li, (should agree well with efit value)
%      q = options.q (a direct copy of the input options.q)
%      psiq, the flux values [Wb] for the q values
%      qprime, dq/dpsi [1/(Wb/rad)]
%      Rq, Zq coordinates for contours of q
%      gaps(ngap,1:5) = [gap, r, z, rs, zs] where gap is distance from (r,z) on limiter to
%        (rs,zs) on the separatrix along vector [gr,gz] = [rs,zs]-[r,z];
%    misc = structure with miscellaneous information about the calculation:
%      execution_began, the date the code was called
%      texec, times at which parts were finished
%      mexec, message about what parts were finished
%      lots of others variables as well
%
%  RESTRICTIONS:
%
%  METHOD:
%    A perturbed Grad-Shafranov equation is solved subject to contraints
%    on the profiles of I(a), W(v),
%    where a, v are normalized area and volume within contours of poloidal flux
%    and I, W are plasma current and thermal energy within the contours.
%    The flux functions pres, and fpol^2/2 are allowed to change by 
%    spline functions (with d(pres)=0 and d(fpol^2/2) = R^2*Bphi*dBphi at edge)
%    A matrix of equations for the perturbed equilibrium is created and solved.
%    The equations are:
%      flux change on grid and current, thermal energy changes within contours
%    The variables being solved for are: 
%      flux change on grid and coeffs for spline functions
%
%    Additional explanation:
%    The change of an axisymmetric equilibrium can be calculated exactly from the
%    Grad-Shafranov equation if changes in applied field, pprime, ffprim are known.
%    This code uses changes of thermal energy versus normalized volume, W(v) and
%    toroidal current versus normalized area, I(a) instead of pprime and ffprim.
%    An empirical scaling between the functions W(v), I(a) and a set of selectable
%    plasma parameters such as {betap, li, Ip} is utilized to completely define the
%    new equilibrium (with {dbetap, dli, dip, dis} as inputs in the example).
%    The returned plasma responses are such that they leave the other selectable
%    parameters unchanged, for instance, dcphidli does not change betap or Ip.
%    The set of selectable parameters is chosen with options.iconstraints where the
%    default 1 corresponds to {betap, li, Ip}
	
%  VERSION %W% %G%
%
%  WRITTEN BY:  Anders Welander  ON	2/25/09
%
%  MODIFICATION HISTORY:				
%               Josiah Wai          1/2/2021
%               Write dpsizrdis to response struct
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % Prelims
  secperday = 24*3600;
  s='In the beginning';
  mexec(1,1:length(s)) = s;
  texec = 0; t0 = now; % For study of execution time
  
  mu0 = .4e-6*pi;
  twopi = 2*pi;
  
  % Unpack tok_data_struct
  tokamak = tok_data_struct.tokamak;
  resc = tok_data_struct.resc;
  resv = tok_data_struct.resv;
  mpp = tok_data_struct.mpp;
  mcc = tok_data_struct.mcc;
  ncc = size(mcc,1);
  mvv = tok_data_struct.mvv;
  nvv = size(mvv,1);
  mcv = tok_data_struct.mcv;
  mpc = tok_data_struct.mpc;
  mpv = tok_data_struct.mpv;
  nr  = tok_data_struct.nr;
  nz  = tok_data_struct.nz;
  ngg = nr*nz;
  rg = tok_data_struct.rg;
  zg = tok_data_struct.zg;
  ccnturn = tok_data_struct.ccnturn;
  imks = tok_data_struct.imks; if imks, iscale=1e6; else iscale=1; end
  dr = mean(diff(rg)); dz = mean(diff(zg));
  rgg = ones(nz,1)*rg';
  zgg = zg*ones(1,nr);
  nee = 0; ecdata = [];
  if isfield(tok_data_struct,'ecdata')
    ecdata = tok_data_struct.ecdata;
    if ~isempty(ecdata), nee = max(ecdata(5,:)); end
  end
  if ~exist('options','var'), options.iconstraints = 1; end
  if isempty(options), options.iconstraints = 1; end
  if ~isstruct(options)
    c0 = options; clear options
    options.iconstraints = c0;
  end
  if ~isfield(options,'iconstraints'), options.iconstraints = 2; end
  if ~isfield(options,'itdinclude'), options.itdinclude = 0; end
  itdinclude = options.itdinclude;
  if itdinclude & isfield(tok_data_struct,'tddata')
    tddata = tok_data_struct.tddata;
    ntd = length(tddata);
    mct = tok_data_struct.mct;
    mpt = tok_data_struct.mpt;
    mtt = tok_data_struct.mtt;
    mvt = tok_data_struct.mvt;
    rest = tok_data_struct.rest;
  else
    ntd = 0; tddata = [];
    mct = zeros(ncc,ntd);
    mpt = zeros(ngg,ntd);
    mtt = zeros(ntd,ntd);
    mvt = zeros(nvv,ntd);
    rest = [];
    options.idxtd = 1:ntd;
  end
  fcdata = tok_data_struct.fcdata;
  vvdata = tok_data_struct.vvdata;
  mss = [[mcc mcv mct];[mcv' mvv mvt];[mct' mvt' mtt]];
  nss = size(mss,1);
  s='Unpacked tok_data_struct';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  
  if ~isfield(options,'q'), options.q = []; end
  if ~isfield(options,'gapspec'), options.gapspec = zeros(0,6); end
  if ~isfield(options,'iso'), options.iso = zeros(0,2); end
  if ~isfield(options,'iverbose'), options.iverbose = 0; end
  if ~isfield(options,'idxcc'), options.idxcc = 1:ncc; end
  if ~isfield(options,'idxvv'), options.idxvv = 1:nvv; end
  if ~isfield(options,'idxtd'), options.idxtd = 1:ntd; end
  if ~isfield(options,'iwait'), options.iwait = 0; end
  if ~exist('idoplots','var'), idoplots = 0; end
  iverbose = options.iverbose;
  idxcc = options.idxcc; idxcc = idxcc(idxcc<=ncc);
  idxvv = options.idxvv; idxvv = idxvv(idxvv<=nvv);
  idxtd = options.idxtd; idxtd = idxtd(idxtd<=ntd);
  iwait = options.iwait;
  gapspec = options.gapspec;
  ngap = size(gapspec,1);
  if size(gapspec,2) < 6 & ngap>0
    gapspec(1,6) = 0;
  end
  gaps = zeros(ngap,5);
  iso = options.iso;
  niso = size(iso,1);

  % Unpack eq
  cpasma = eq.cpasma;
  psimag = eq.psimag;
  psibry = eq.psibry;
  jphi = eq.jphi;
  jphi0 = iscale*eq.jphi; % jphi0 in units consistent with tok_data_struct (mpp)
  cphi = jphi0*dr*dz;
  psizr = eq.psizr;
  rzero = eq.rzero;
  fpol = eq.fpol;
  pres = eq.pres;
  pprime = eq.pprime;
  ffprim = eq.ffprim;
  rbbbs = eq.rbbbs(1:eq.nbbbs);
  zbbbs = eq.zbbbs(1:eq.nbbbs);
  ra = eq.rmaxis;
  za = eq.zmaxis;
  if isfield(eq,'qpsi')
    qpsi = eq.qpsi;
  else
    qpsi = zeros(nr,1);
  end
  psizr_r = [zeros(nz,1) psizr(:,3:end)-psizr(:,1:end-2) zeros(nz,1)]/2/dr;
  psizr_z = [zeros(1,nr);psizr(3:end,:)-psizr(1:end-2,:);zeros(1,nr)]/2/dz;
  psibarzr = (psizr-psimag)/(psibry-psimag);
  iplasma = find(jphi); ivac = setdiff(1:ngg,iplasma);
  psigrid = linspace(psimag,psibry,nr)'; % Wb
  dpsigrid = psigrid(2)-psigrid(1);
  s='Unpacked eq';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  
  sumcphi = sum(cphi(:));
  rcur = sum(rgg(:).*cphi(:))/sumcphi;
  zcur = sum(zgg(:).*cphi(:))/sumcphi;
  psipla = cphi(:)'*psizr(:)/sumcphi;
  
  % Check that fpol, qpsi are okay
  if ~isempty(find(isnan(fpol))) | min(fpol)==max(fpol) | ~isempty(find(isnan(qpsi))) | min(qpsi)==max(qpsi)
    if iwait & ~isempty(options.q)
      wait('WARNING gspert: Equilibrium has no fpol, qpsi')
    elseif iverbose >= 0
      disp('WARNING gspert: Equilibrium has no fpol, qpsi')
    end
    fpol = ones(nr,1); qpsi = zeros(nr,1);
  end
  if iverbose >= 2, disp('Finding flux at q surfaces'); end
  q = options.q; nq = length(q); psiq = []; qprime = [];
  for j = 1:nq
    if q(j)<max(qpsi) & q(j)>min(qpsi)
      k = nr-1; % Searching for q(j) value in qpsi array
      while (qpsi(k)-q(j))*(qpsi(k+1)-q(j)) > 0 & k > 1
	k=k-1;
      end
      k2 = min(nr-2,k+1); while (qpsi(k2+1)-qpsi(k2))*(qpsi(k2+2)-qpsi(k2+1))>0 & k2<nr-2, k2 = k2+1; end
      k1 = min(nr-2,k); while (qpsi(k1+2)-qpsi(k1+1))*(qpsi(k1+1)-qpsi(k1))>0 & k1>1, k1 = k1-1; end
      psiq(j) = spline(qpsi(k1:k2),psigrid(k1:k2),q(j));
      qprime(j) = (spline(psigrid(k1:k2),qpsi(k1:k2),psiq(j)+1e-6) - ...
                   spline(psigrid(k1:k2),qpsi(k1:k2),psiq(j)-1e-6))*pi*1e6;
    else
      psiq(j) = NaN; qprime(j) = NaN;
    end
  end

  if iverbose >= 2, disp('Checking that pres is okay'); end
  if max(abs(pres)) == 0
    if iwait
      wait('WARNING gspert: pres=0. Making pres from pprime.')
    elseif iverbose >= 0
      disp('WARNING gspert: pres=0. Making pres from pprime.')
    end
    if max(abs(pprime)) == 0
      if iwait
	wait('WARNING gspert: pprime=0. Changing it to linspace(0,1,nr)''.')
      elseif iverbose >= 0
	disp('WARNING gspert: pprime=0. Changing it to linspace(0,1,nr)''.')
      end
      pprime = linspace(0,1,nr)';
    end
    c0 = spline(1:nr,pprime,1+1/64:1/32:nr);
    pres(nr) = 0;
    for j = nr-1:-1:1
      pres(j) = pres(j+1) - sum(c0(j*32-31:j*32))*dpsigrid/64/pi;
    end
  end
  if min(pres) < 0
    if iwait
      wait('WARNING gspert: Equilibrium has min(pres) < 0')
    elseif iverbose >= 0
      disp('WARNING gspert: Equilibrium has min(pres) < 0')
    end
  end
  
  % For the splines that describe dpres and d(fpol^2/2)
  % c1, c2, c3 are determined based on boundary conditions.
  % Hence these are new linear combination of old coeffs for each new interval
  nkn = (nr-1)/2-2; % number of spline knots, the choice seems to have very little effect
  nkn = round(log(nr-1)/log(2)); % Smaller number gives smoother dffprim, dpprime, should be more physical
  if isfield(options,'nkn'), nkn = options.nkn; end % User option on nkn overrides the default
  psikn = linspace(psimag,psibry,nkn+1);
  c1 = [0 0 1]; c2 = [0 1 0]; c3 = [1 0 0];
  c0 = -c1*psibry-c2*psibry^2-c3*psibry^3;
  x = [1 1 1; 1 2 3; 0 2 6]; e = [1 2 3; 0 1 2; 0 0 1];
  for j = nkn:-1:2
    c0(end+1,end+1) = 1; c = inv(psikn(j).^e.*x)*[1;0;0];
    c1(end+1,1:end+1) = c(1)*(c0(end-1,:)-c0(end,:)); c1(end,:) = c1(end,:)+c1(end-1,:);
    c2(end+1,1:end+1) = c(2)*(c0(end-1,:)-c0(end,:)); c2(end,:) = c2(end,:)+c2(end-1,:);
    c3(end+1,1:end+1) = c(3)*(c0(end-1,:)-c0(end,:)); c3(end,:) = c3(end,:)+c3(end-1,:);
  end
  c0 = c0(end:-1:1,end:-1:1);c1 = c1(end:-1:1,end:-1:1);c2 = c2(end:-1:1,end:-1:1);c3 = c3(end:-1:1,end:-1:1);

  if iverbose >= 2, disp('Computing derivatives on the grid'); end
  Pprime = spline(psigrid,pprime,psizr);
  FFprim = spline(psigrid,ffprim,psizr);
  P = spline(psigrid,pres,psizr);
  pb = (spline(psigrid,pprime,psigrid+1e-6)-spline(psigrid,pprime,psigrid-1e-6))*pi*1e6;
  Pbis = spline(psigrid,pb,psizr);
  gb = (spline(psigrid,ffprim,psigrid+1e-6)-spline(psigrid,ffprim,psigrid-1e-6))*pi*1e6;
  Gbis = spline(psigrid,gb,psizr);
  % Try a different way to calculate Pbis, Gbis
  if 0
    for j = 2:nr
      k = find(psizr <= psigrid(j));
      Pbis(k) = (pprime(j)-pprime(j-1))/dpsigrid*2*pi;
      Gbis(k) = (ffprim(j)-ffprim(j-1))/dpsigrid*2*pi;
    end
  end
  djdp = (rgg.*Pbis+Gbis/mu0./rgg)/twopi; djdp(ivac)=0;
  
  % Find weights in grid points to calculate value at a point using cubic Hermite spline (ref. wikipedia)
  mx = [0 2 0 0;-1 0 1 0;2 -5 4 -1;-1 3 -3 1]/2;
  neighbors = reshape([-1-nz -1 -1+nz -1+2*nz;-nz 0 nz 2*nz;1-nz 1 1+nz 1+2*nz;2-nz 2 2+nz 2+2*nz],1,16);

  if iverbose >= 2, disp('Finding magnetic axis'); end
  for j=1:9
    kr0 = min(nr-3,max(1,floor((ra-rg(1))/dr))); % r index 0-start, allowed values: 1:nr-3
    kz1 = min(nz-2,max(2,ceil((za-zg(1))/dz))); % z index 1-start, allowed values: 2:nz-2
    k = kr0*nz+kz1;
    iia = k+neighbors; % iia indexes 16 points around magnetic axis
    pp = psizr(iia);
    tr = (ra-rgg(k))/dr; tz = (za-zgg(k))/dz;
    wa = reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    war = reshape(([1 tz tz^2 tz^3]*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    waz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    warr = reshape(([1 tz tz^2 tz^3]*mx)'*[0 0 2 6*tr]/dr^2*mx,1,16);
    wazz = reshape(([0 0 2 6*tz]/dz^2*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    warz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    ashift_Ba = -inv([pp*warr' pp*warz';pp*warz' pp*wazz']);
    % The following check fixes problem with NSTX EFIT02 #141640, 0.07 sec which has two axes and x in plasma
    if ashift_Ba(1,1)*ashift_Ba(2,1)>=0 & ashift_Ba(1,2)*ashift_Ba(2,2)>=0
      c = ashift_Ba*[pp*war'; pp*waz']; ra = ra+c(1); za = za+c(2);
    end
  end
  if iverbose >= 2, disp('Finding what defines the separatrix'); end
  if isfield(tok_data_struct,'limdata')
    limdata = tok_data_struct.limdata;
    if size(limdata,2)<size(limdata,1), limdata=limdata'; end
    rlimdata = limdata(2,:); zlimdata = limdata(1,:);
    if rlimdata(1)~=rlimdata(end) | zlimdata(1)~=zlimdata(end)
      rlimdata = rlimdata([1:end 1]); zlimdata = zlimdata([1:end 1]);
    end
    nlim = length(rlimdata);
    r = interp1(1:nlim,rlimdata,1:.01:nlim);
    z = interp1(1:nlim,zlimdata,1:.01:nlim);
    for j=1:length(r) % Distance check to rbbbs,zbbbs needed because psilim can max around x-point
      d2minlimbbbs(j) = min((rbbbs-r(j)).^2+(zbbbs-z(j)).^2);
    end
    psibarlim = interp2(rg,zg,psibarzr,r,z,'spline');
    k = find(z<max(zbbbs) & z>min(zbbbs) & d2minlimbbbs<dr^2);
    if isempty(k)
      [dum, k] = min(d2minlimbbbs);
    else
      [dum, l] = min(psibarlim(k));
      k = k(l);
    end
    k1 = k-1; if k1<1, k1 = length(r); end
    k2 = k+1; if k2>length(r), k2 = 1; end
    d1 = min(-sqrt((r(k1)-r(k))^2+(z(k1)-z(k))^2),-1e-19);
    d2 = max(+sqrt((r(k2)-r(k))^2+(z(k2)-z(k))^2),+1e-19);
    if (psibarlim(k1)-psibarlim(k))*(psibarlim(k2)-psibarlim(k))>0
      warning off; p = polyfit([d1 0 d2],psibarlim([k1 k k2])-psibarlim(k),2); d = -p(2)/2/p(1); warning on
    else
      d = 0;
    end
    rlim = spline([d1 0 d2],r([k1 k k2]),d); zlim = spline([d1 0 d2],z([k1 k k2]),d);
    drlim = spline([d1 0 d2],r([k1 k k2]),d+1e-6)-spline([d1 0 d2],r([k1 k k2]),d-1e-6);
    dzlim = spline([d1 0 d2],z([k1 k k2]),d+1e-6)-spline([d1 0 d2],z([k1 k k2]),d-1e-6);
    ulim = [drlim; dzlim]/sqrt(drlim^2+dzlim^2);
    kr0 = min(nr-3,max(1,floor((rlim-rg(1))/dr))); % r index 0-start, allowed values: 1:nr-3
    kz1 = min(nz-2,max(2,ceil((zlim-zg(1))/dz))); % z index 1-start, allowed values: 2:nz-2
    k = kr0*nz+kz1;
    iilim = k+neighbors;
    tr = (rlim-rgg(k))/dr; tz = (zlim-zgg(k))/dz;
    wl = reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wld = reshape(([1 tz tz^2 tz^3]*mx)'*[0 1 2*tr 3*tr^2]*mx*ulim(1)/dr+...
                   ([0 1 2*tz 3*tz^2]*mx)'*ulim(2)/dz*[1 tr tr^2 tr^3]*mx,1,16);
    wlb = reshape(([1 tz tz^2 tz^3]*mx)'*[0 0 2 6*tr]*mx*ulim(1)^2/dr^2+...
                   ([0 0 2 6*tz]*mx)'*ulim(2)^2/dz^2*[1 tr tr^2 tr^3]*mx+...
		 2*([0 1 2*tz 3*tz^2]*mx)'*ulim(2)/dz*[0 1 2*tr 3*tr^2]*mx*ulim(1)/dr,1,16);
    psilimbis = psizr(iilim)*wlb';
    psibartouch = psibarzr(iilim)*wl'; % The lowest psibar on the limiter, should always be >=1
  else
    disp('gspert: Found no limiter data. Assuming diverted plasma.')
    if iwait, pause, end
    psibartouch = 1e9;
  end
  % Find dominant x-point
  [dum, k] = min(interp2(rg,zg,psizr_r.^2+psizr_z.^2,rbbbs,zbbbs,'spline'));
  rx = rbbbs(k);
  zx = zbbbs(k);
  c_previous = zg(end)-zg(1);
  cx = c_previous*.99;
  counter = 0;
  done = 0;
  % Try zooming in on x-point with Newton Rhapson.
  while ~done
    counter = counter+1;
    % Find indices and weights for grid points around the x-point
    jr = (rx-rg(1))/dr;
    iz = (zx-zg(1))/dz;
    j = max(2,min(nr-2,floor(jr)+1));
    i = max(2,min(nz-2,floor(iz)+1));
    tr = jr-j;
    tz = iz-i;
    k = i+(j-1)*nz;
    iix = k+neighbors; % iix indexes 16 points around x point
    pp = psizr(iix);
    c_previous = cx;
    wx = reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wxr = reshape(([1 tz tz^2 tz^3]*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    wxz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wxrr = reshape(([1 tz tz^2 tz^3]*mx)'*[0 0 2 6*tr]/dr^2*mx,1,16);
    wxzz = reshape(([0 0 2 6*tz]/dz^2*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wxrz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    xshift_Bx = -inv([pp*wxrr' pp*wxrz';pp*wxrz' pp*wxzz']);
    cx = xshift_Bx*[pp*wxr'; pp*wxz'];
    rx = rx + cx(1);
    zx = zx + cx(2);
    done = norm(c_previous) < norm(cx) | ...
      counter > 9 | rx < rg(2) | rx > rg(nr-1) | zx < zg(2) | zx > zg(nz-1);
  end
  psibarx = psibarzr(iix)*wx';
  psix = psizr(iix)*wx';
  if ((rx-ra)/dr)^2+((zx-za)/dz)^2 < 4 % It's not an x-point, it's the axis
    psibarx = inf;
    psix = inf*(psibry-psimag);
  end
  % Look for a second null and calculate drsep
  j = find((zbbbs-za).*(zx-za)<0);
  [dum, k] = min(interp2(rg,zg,psizr_r.^2+psizr_z.^2,rbbbs(j),zbbbs(j),'spline'));
  rx2 = rbbbs(j(k));
  zx2 = zbbbs(j(k));
  c_previous = zg(end)-zg(1);
  c = c_previous*.99;
  counter = 0;
  done = 0;
  while ~done
    counter = counter+1;
    % Find indices and weights for grid points around this second x-point
    jr = (rx2-rg(1))/dr;
    iz = (zx2-zg(1))/dz;
    j = max(2,min(nr-2,floor(jr)+1));
    i = max(2,min(nz-2,floor(iz)+1));
    tr = jr-j;
    tz = iz-i;
    k = i+(j-1)*nz;
    iix2 = k+neighbors; % iix2 indexes 16 points around 2:nd x point
    pp = psizr(iix2);
    c_previous = c;
    wx2 = reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wx2r = reshape(([1 tz tz^2 tz^3]*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    wx2z = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wx2rr = reshape(([1 tz tz^2 tz^3]*mx)'*[0 0 2 6*tr]/dr^2*mx,1,16);
    wx2zz = reshape(([0 0 2 6*tz]/dz^2*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    wx2rz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    x2shift_Bx = -inv([pp*wx2rr' pp*wx2rz';pp*wx2rz' pp*wx2zz']);
    c = x2shift_Bx*[pp*wx2r'; pp*wx2z'];
    rx2 = rx2+c(1);
    zx2 = zx2+c(2);
    done = norm(c_previous) < norm(cx) | ...
      counter > 9 | rx < rg(2) | rx > rg(nr-1) | zx < zg(2) | zx > zg(nz-1);
  end
  psibarx2 = psibarzr(iix2)*wx2';
  psix2 = psizr(iix2)*wx2';
  if ((rx2-ra)/dr)^2+((zx2-za)/dz)^2 < 4 % It's not an x-point, it's the axis
    psibarx2 = inf;
    psix2 = inf*(psibry-psimag);
  end
  rsep = max(rbbbs);
  l=0;
  k = 1+floor((rsep-rg(1))/dr)*nz+floor((za-zg(1))/dz);
  while l<3 & k>1+nz & k<=ngg-2-2*nz
    l=l+1; iisep = k+neighbors; pp = psizr(iisep)';
    tr = (rsep-rgg(k))/dr; tz = (za-zgg(k))/dz;
    wsep = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
    TD = [1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]/dr;
    wsepd = reshape(mx'*TD*mx,1,16); % Weights to calculate dpsi/drho
    dpsidrho = wsepd*pp; % dpsi/drho
    rsep = rsep+(psibry-wsep*pp)/dpsidrho;
    k = 1+floor((rsep-rg(1))/dr)*nz+floor((za-zg(1))/dz);
  end
  drsepdpsi = 1/dpsidrho;
  drsep = (psix2-psix)*drsepdpsi;
  TB = [1 tz tz^2 tz^3]'*[0 0 2 6*tr]/dr^2;
  wsepb = reshape(mx'*TB*mx,1,16); % Weights to calculate d2psi/drho2
  d2rsepdpsi2 = -wsepb*psizr(iisep)'*drsepdpsi^3;
  % Look for strike points, even for nulls that don't define the boundary
  rstrike(1:4) = NaN; zstrike(1:4) = NaN; % lower inner, lower outer, upper inner, upper outer
  drstrikedpsi(1:4) = NaN; dzstrikedpsi(1:4) = NaN; iistrike = ones(4,32); wstrike = zeros(4,32);
  m = find((psibarlim(1:end-1)-psibarx).*(psibarlim(2:end)-psibarx)<0); % index possible points
  [dum, k] = sort((r(m)-rx).^2+(z(m)-zx).^2); % Find candidates closest to strong x-point
  if length(k) >= 2
    m = m(k(1:2)); % Pick closest candidates
    [dum, j] = sort(r(m)); m = m(j); % Sort those 2 w.r.t. R
  end
  for j=1:min(2,length(m))
    if zx>za, j2=j+2; else j2=j; end
    k = m(j)+[0 1]; drs = diff(r(k)); dzs = diff(z(k));
    rstrike(j2) = spline(psibarlim(k),r(k),psibarx);
    zstrike(j2) = spline(psibarlim(k),z(k),psibarx);
    k = 1+floor((rstrike(j2)-rg(1))/dr)*nz+floor((zstrike(j2)-zg(1))/dz);
    tr = (rstrike(j2)-rgg(k))/dr; tz = (zstrike(j2)-zgg(k))/dz;
    wstrike(j2,:) = [reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16) -wx];
    iistrike(j2,:) = [k+neighbors iix]; pp = psizr(iistrike(j2,1:16));
    wr = reshape(([1 tz tz^2 tz^3]*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    wz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    pd = (pp*wr'*drs+pp*wz'*dzs);
    drstrikedpsi(j2,1) = -drs/pd;
    dzstrikedpsi(j2,1) = -dzs/pd;
  end
  m = find((psibarlim(1:end-1)-psibarx2).*(psibarlim(2:end)-psibarx2)<0); % possible points
  [dum, k] = sort((r(m)-rx2).^2+(z(m)-zx2).^2); % Candidates closest to weak x-point
  if length(k) >= 2
    m = m(k(1:2)); % Pick closest candidates
    [dum, j] = sort(r(m)); m = m(j); % Sort those 2 w.r.t. R
  end
  for j=1:min(2,length(m))
    if zx2>za, j2=j+2; else j2=j; end
    k = m(j)+[0 1]; drs = diff(r(k)); dzs = diff(z(k));
    rstrike(j2) = spline(psibarlim(k),r(k),psibarx2);
    zstrike(j2) = spline(psibarlim(k),z(k),psibarx2);
    kr0 = min(nr-3,max(1,floor((rstrike(j2)-rg(1))/dr))); % r index 0-start, allowed values: 1:nr-3
    kz1 = min(nz-2,max(2,ceil((zstrike(j2)-zg(1))/dz))); % z index 1-start, allowed values: 2:nz-2
    k = kr0*nz+kz1;
    tr = (rstrike(j2)-rgg(k))/dr; tz = (zstrike(j2)-zgg(k))/dz;
    wstrike(j2,:) = [reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16) -wx2];
    iistrike(j2,:) = [k+neighbors iix2]; pp = psizr(iistrike(j2,1:16));
    wr = reshape(([1 tz tz^2 tz^3]*mx)'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    wz = reshape(([0 1 2*tz 3*tz^2]/dz*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
    pd = (pp*wr'*drs+pp*wz'*dzs);
    drstrikedpsi(j2,1) = -drs/pd;
    dzstrikedpsi(j2,1) = -dzs/pd;
  end
% Decide which point defines the boundary
  if psibartouch<psibarx | norm(cx)>max(dr,dz)/100
    ilimited = 1;
    r0 = rlim; r0descr = 'R of touch point that limits plasma';
    z0 = zlim; z0descr = 'Z of touch point that limits plasma';
    if iverbose >= 2, disp(['Plasma is limited with Rtouch = ' num2str(r0) ', Ztouch = ' num2str(z0)]); end
  else
    ilimited = 0;
    r0 = rx; r0descr = 'R of dominant x-point';
    z0 = zx; z0descr = 'Z of dominant x-point';
    if z0>za, j2=2; else j2 = 0; end
    if iverbose >= 2
      disp(['Diverted plasma with xpoint at (' num2str(r0) ',' num2str(z0) ')']);
      disp(['and with inner strike point at (' num2str(rstrike(1+j2)) ',' num2str(zstrike(1+j2)) ')']);
      disp(['and with outer strike point at (' num2str(rstrike(2+j2)) ',' num2str(zstrike(2+j2)) ')']);
    end
  end
  drstrike = rstrike(:); dzstrike = zstrike(:);
  % Find indices and weights for grid points around the boundary defining point
  kr0 = min(nr-3,max(1,floor((r0-rg(1))/dr))); % r index 0-start, allowed values: 1:nr-3
  kz1 = min(nz-2,max(2,ceil((z0-zg(1))/dz))); % z index 1-start, allowed values: 2:nz-2
  k = kr0*nz+kz1;
  ii0 = k+neighbors; % ii0 indexes 16 points around limiting point
  tr = (r0-rgg(k))/dr; tz = (z0-zgg(k))/dz;
  w0 = reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
  s='Found axis, lim, x, strike points';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;

  if iverbose >= 2, disp('Deeper analysis of plasma geometry...'); end
  na = (nr-1); % Number of contour slices
  L = zeros(nr,1); % Integral of dA/mu0/R enclosed by flux of values in variable psigrid
  A = zeros(nr,1); % Areas enclosed by flux of values in variable psigrid
  V = zeros(nr,1); % Volumes enclosed by flux of values in variable psigrid
  I = zeros(nr,1); % Current enclosed by flux of values in variable psigrid
  W = zeros(nr,1); % Thermal energy enclosed by flux of values in variable psigrid
  L_psizr = zeros(nr,ngg); % How L changes when flux map changes.
  A_psizr = zeros(nr,ngg); % How A changes when flux map changes.
  V_psizr = zeros(nr,ngg); % How V changes when flux map changes.
  I_psizr = zeros(nr,ngg); % How I changes when flux map changes.
  W_psizr = zeros(nr,ngg); % How W changes when flux map changes.
  In_psizr = zeros(nr,ngg); % How I versus normalized area changes when flux map changes.
  Wn_psizr = zeros(nr,ngg); % How W versus normalized volume changes when flux map changes.
  I_g = zeros(nr,2*nkn+4); % How I changes when pres, f2 change.
  W_g = zeros(nr,2*nkn+4); % How W changes when pres, f2 change.
  rhob_psizr = zeros(na,ngg); % How the boundary rho changes when flux map changes.
  rq = zeros(na,nq); % R of q-surfaces with values in q at fluxes psiq
  zq = zeros(na,nq); % Z of q-surfaces with values in q at fluxes psiq
  drq = rq; dzq = zq; % Perturbations (defined here to work with nq=0)
  rhoq_psizr = zeros(na*nq,ngg); % How rho of normalized flux changes at q contours when flux map changes.
  dqdrho = zeros(na,nq); % dq/drho at the q-contours
  th0 = angle(r0-ra+sqrt(-1)*(z0-za)); dth = twopi/na; ths = th0+linspace(0,twopi-dth,na);
  % Contour plasma and calculate L, A, V one slice at a time
  Rcnt = ra+zeros(na,nr); Zcnt = za+zeros(na,nr); rhob = zeros(1,na);
  
  s='Allocated memory for contouring';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  
  for ia=1:na
    th = th0+dth*(ia-1);
    % previous indices, weights, grid point
    drh = mean([dr dz]); R = ra; Z = za;
    for j=2:nr
      a = (1-(j-1)/(nr-1)); R=R+drh*cos(th); Z=Z+drh*sin(th);
      if ia==1 & j==nr
        R=r0; Z=z0; iip = ii0; k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); drhodpsi=0; wp=w0;
      else % Newton-Rhapson to find exact rho according to the cubic Hermite spline.
	l=0;
        while l<3
	  l=l+1; k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
	  if min(iip)>0 & max(iip)<nr*nz
	    pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
	    wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
	    TD = [0 1 2*tz 3*tz^2]'*sin(th)/dz*[1 tr tr^2 tr^3]+[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]*cos(th)/dr;
	    wpd = reshape(mx'*TD*mx,1,16); % Weights to calculate dpsi/drho
	    dpsidrho = wpd*pp; % dpsi/drho
	    newdrh = (psigrid(j)-wp*pp)/dpsidrho; % The small drho needed to get to the point where wp*pp = psigrid(j)
	  else % In this case we have somehow drifted outside grid
	    R = ra; Z = za; newdrh = 1e22; % Reset R, Z and make newdrh big to switch to interval halving
	  end
	  if abs(newdrh)>abs(drh) % Diverging so switch to interval halving method
	    drh = mean([dr dz]); psi2 = psimag; psi1 = psimag;
	    while l<30
	      l=l+1;
	      R = R+drh*cos(th); Z = Z+drh*sin(th);
	      k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
	      if min(iip)<1 | max(iip)>ngg
	        R=ra; Z=za; drh=drh/2; % Try again
	      else
	        tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
	        wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
	        psi1 = wp*psizr(iip)';
	      end
	      if (psi1-psigrid(j))*(psi2-psigrid(j))<=0
	        drh = -drh/2;
	      end
	      psi2 = psi1;
	    end
	  else
	    drh = newdrh; R = R+drh*cos(th); Z = Z+drh*sin(th);
	  end
	  if drh == 0, break, end
         drhodpsi = 1/dpsidrho; % Generally xprime = 1/yprime & xbis=-ybis/yprime^3
	end % End of Newton-Rhapson to find R, Z, dpsidrho      
      end % End of if ia==1 & j==nr
      DR = R-ra; DZ = Z-za;
      rho = sqrt(DR^2+DZ^2); rhov(j) = rho;
      tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
      wp = reshape(([1 tz tz^2 tz^3]*mx)'*[1 tr tr^2 tr^3]*mx,1,16);
      
      if abs(cos(th))>1e-4
        L(j) = L(j) + dth*(rho/cos(th)-ra/cos(th)^2*log(R/ra));% http://www.wolframalpha.com/input/?i=integral(x%2F(R%2Bx*t)*dx)
      else
        L(j) = L(j) + dth*rho^2/2/ra; % Adding contour slice area
      end
      l_psi = -rho*dth/R*drhodpsi;
      L_psizr(j,iip) = L_psizr(j,iip) + wp*l_psi;
      L_psizr(j,iia) = L_psizr(j,iia) - wa*l_psi*a;
      L_psizr(j,ii0) = L_psizr(j,ii0) - w0*l_psi*(1-a);
      
      A(j) = A(j) + dth*rho^2/2; % Adding contour slice area
      a_psi = -rho*dth*drhodpsi;
      A_psizr(j,iip) = A_psizr(j,iip) + wp*a_psi;
      A_psizr(j,iia) = A_psizr(j,iia) - wa*a_psi*a;
      A_psizr(j,ii0) = A_psizr(j,ii0) - w0*a_psi*(1-a);

      V(j) = V(j) + twopi*rho^2*(ra/2+rho*cos(th)/3)*dth; % A formula for the volume of a slice of cylinder
      v_psi = -twopi*R*rho*dth*drhodpsi;
      V_psizr(j,iip) = V_psizr(j,iip) + wp*v_psi;
      V_psizr(j,iia) = V_psizr(j,iia) - wa*v_psi*a;
      V_psizr(j,ii0) = V_psizr(j,ii0) - w0*v_psi*(1-a);

      Rcnt(ia,j) = R; Zcnt(ia,j) = Z; drh = sqrt((R-Rcnt(ia,j-1))^2+(Z-Zcnt(ia,j-1))^2);
    end % End of j=2:nr loop
    rhob(ia) = rho; 
    rhob_psizr(ia,iip) = rhob_psizr(ia,iip)-drhodpsi*wp;
    rhob_psizr(ia,ii0) = rhob_psizr(ia,ii0)+drhodpsi*w0;
    didrhob(ia) = (R*pprime(end)+ffprim(end)/mu0/R)*rho*dth;
    dibdpsi(ia) = -drhodpsi*didrhob(ia); % di(boundary)/dpsi(boundary)
    ib(ia) = k; wbs(ia,:) = wp;
    
    if nq>0 & max(qpsi)>min(qpsi)
      rhoq = spline(psigrid,rhov,psiq); % Contour q-surfaces
      dqdrho(ia,:) = (spline(rhov,qpsi,rhoq+1e-6)-spline(rhov,qpsi,rhoq-1e-6))/2e-6;
      rq(ia,:) = ra+rhoq*cos(th); zq(ia,:) = za+rhoq*sin(th);
      for j = find(~isnan(rhoq))
        a = (rhoq(j)-psibry)/(psimag-psibry);
        R = ra+rhoq(j)*cos(th); Z = za+rhoq(j)*sin(th);
        k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
	if min(iip) > 0 & max(iip) <= ngg
	  pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
	  wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
	  TD = [0 1 2*tz 3*tz^2]'*sin(th)/dz*[1 tr tr^2 tr^3]+[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]*cos(th)/dr;
	  wpd = reshape(mx'*TD*mx,1,16); % Weights to calculate dpsi/drho
	  dpsidrho = wpd*pp; drhodpsi = 1/dpsidrho;
          rhoq_psizr(ia+(j-1)*na,iip) = rhoq_psizr(ia+(j-1)*na,iip)-drhodpsi*wp;
          rhoq_psizr(ia+(j-1)*na,iia) = rhoq_psizr(ia+(j-1)*na,iia)+drhodpsi*wa*a;
          rhoq_psizr(ia+(j-1)*na,ii0) = rhoq_psizr(ia+(j-1)*na,ii0)+drhodpsi*w0*(1-a);
	end
      end
    end
    s=['Found rho for ia=' num2str(ia)];
    mexec(end+1,1:length(s)) = s;
    texec(end+1) = (now-t0)*secperday;
  end % End of ia loop
  Lprime = (spline(psigrid,L,psigrid+1e-6)-spline(psigrid,L,psigrid-1e-6))*pi*1e6;
  dqpsidbphi = qpsi*rzero./fpol;
  if max(fpol)>min(fpol)
    dqpsiq = spline(psigrid,dqpsidbphi,psiq);
  else
    dqpsiq = NaN*psiq;
  end
  for j = 1:nq
    drhoq(:,j) = -dqpsiq(j)./dqdrho(:,j); % The new rho for the q
    drq(:,j) = drhoq(:,j).*cos(ths)'; dzq(:,j) = drhoq(:,j).*sin(ths)';
  end
  drqdbphi = drq(:); dzqdbphi = dzq(:);
  W(2:nr) = cumsum((pres(2:end)+pres(1:end-1)).*diff(V))*3/4;
  I(2:nr) = cumsum((pprime(2:end)+pprime(1:end-1)).*diff(V)/4/pi+(ffprim(2:end)+ffprim(1:end-1)).*diff(L)/mu0/2);
%  I = I*cpasma/I(end);
  for j=2:nr
    I_psizr(j,:) = (pprime(j-1)+pprime(j))*(V_psizr(j,:)-V_psizr(j-1,:))/4/pi+...
    		   (ffprim(j-1)+ffprim(j))*(L_psizr(j,:)-L_psizr(j-1,:))/2/mu0;
    I_psizr(j,iia) = I_psizr(j,iia)-wa*(I(j)-I(j-1))/(psimag-psibry);
    I_psizr(j,ii0) = I_psizr(j,ii0)+w0*(I(j)-I(j-1))/(psimag-psibry);
    W_psizr(j,:) = 3/4*(pres(j-1)+pres(j))*(V_psizr(j,:)-V_psizr(j-1,:));
  end
  I_psizr = cumsum(I_psizr); W_psizr = cumsum(W_psizr); % Are now changes within contours
  I_An = (spline(A/A(end),I,A/A(end)+1e-6)-spline(A/A(end),I,A/A(end)-1e-6))/2e-6;
  W_Vn = (spline(V/V(end),W,V/V(end)+1e-6)-spline(V/V(end),W,V/V(end)-1e-6))/2e-6; % 3/2pres*V(end)
  % Add contributions from change in contours
  for j = 2:nr
    % The profile constraints concern In = I(A/Atot) and Wn = Wth(V/Vtot)
    % so we subtract desired change within contours of normalized flux
    In_psizr(j,:) = I_psizr(j,:) - I_An(j)/A(end)*(A_psizr(j,:)-A(j)/A(end)*A_psizr(end,:));
    %Wn_psizr(j,:) = W_psizr(j,:) - W_Vn(j)/V(end)*(V_psizr(j,:)-V(j)/V(end)*V_psizr(end,:));
    Wn_psizr(j,:) = W_psizr(j,:) - 1.5*pres(j)*(V_psizr(j,:)-V(j)/V(end)*V_psizr(end,:));
    % How current and thermal energy changes in contours when spline coeffs change
    x = mean(psigrid(j-1:j)); k = fix(min(nkn,1+nkn*(x-psimag)/(psibry-psimag)));
    I_g(j,1:nkn+2) = (V(j)-V(j-1))*(c1(k,:)+2*c2(k,:)*x+3*c3(k,:)*x^2);
    I_g(j,nkn+2+(1:nkn+2)) = (L(j)-L(j-1))/mu0*(c1(k,:)+2*c2(k,:)*x+3*c3(k,:)*x^2)*twopi;
    W_g(j,1:nkn+2) = 1.5*(V(j)-V(j-1))*(c0(k,:)+c1(k,:)*x+c2(k,:)*x^2+c3(k,:)*x^3);
  end
  % Calculate betap, li
  dVedgedrho = twopi*Rcnt(:,end)'.*rhob*dth;
  Bp2zr = (psizr_r.^2+psizr_z.^2)/twopi^2./rgg.^2;
  Bp2edge = interp2(rg,zg,Bp2zr,Rcnt(:,end),Zcnt(:,end),'spline')';
  I_g = cumsum(I_g); W_g = cumsum(W_g);
  DX = diff(Rcnt([1:na 1],end)'); DY = diff(Zcnt([1:na 1],end)');
  cpieces = sqrt(DX.^2+DY.^2);
  Cl = sum(cpieces); % Contour length
  bp2flx = (mu0*cpasma/Cl)^2;
  betap = 4/3*mu0*W(end)/V(end)/bp2flx; % 2*mu0 * Volume-averaged pressure / bp2flx
  Bp2V = sum(dr*dz*twopi*rgg(iplasma).*Bp2zr(iplasma));
  li = Bp2V/V(end)/bp2flx; % Volume-averaged Bp^2 / bp2flx
  % Calculate gaps and their responses using specification, gapspec
  % If we should plot then calculate some extra points to show the divertor legs
  nextragap1 = 0; nextragap2 = 0;
  if max(abs(idoplots)) > 0 & ~ilimited
    nextragap1 = round(norm([rx-rstrike(1+j2) zx-zstrike(1+j2)])/dr);
    rr = linspace(rstrike(1+j2),rx,nextragap1+2)';
    zz = linspace(zstrike(1+j2),zx,nextragap1+2)';
    gapspec(end+1:end+nextragap1,5:6) = [rr(2:end-1) zz(2:end-1)];
    nextragap2 = round(norm([rx-rstrike(2+j2) zx-zstrike(2+j2)])/dr);
    rr = linspace(rx,rstrike(2+j2),nextragap2+2)';
    zz = linspace(zx,zstrike(2+j2),nextragap2+2)';
    gapspec(end+1:end+nextragap2,5:6) = [rr(2:end-1) zz(2:end-1)];
  end
  for j=1:ngap+nextragap1+nextragap2
    R = gapspec(j,1); Z = gapspec(j,2);
    if R ~= 0
      gr = gapspec(j,3); gz = gapspec(j,4); gapspec_option = 1;
    else % If R==0, look for specified separatrix point and set (gr,gz) = gradient(psi)
      R = gapspec(j,5); Z = gapspec(j,6); gapspec_option = 2;
      k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
      pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
      wpr = reshape(mx'*[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
      wpz = reshape(mx'*[0 1 2*tz 3*tz^2]'/dz*[1 tr tr^2 tr^3]*mx,1,16);
      gr = wpr*pp; gz = wpz*pp;
    end
    k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
    ur = gr/norm([gr gz]); uz = gz/norm([gr gz]);
    pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
    wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
    psigap = wp*pp;
    TD = [0 1 2*tz 3*tz^2]'*uz/dz*[1 tr tr^2 tr^3]+[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]*ur/dr;
    wpd = reshape(mx'*TD*mx,1,16); % Weights to calculate dpsi/dg
    dpsidgap0 = wpd*pp;
    l = 0; drh = 1e9;
    while l<3
      l = l+1;
      k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
      if min(iip)>0 & max(iip)<nr*nz
	pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
	wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
	TD = [0 1 2*tz 3*tz^2]'*uz/dz*[1 tr tr^2 tr^3]+[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]*ur/dr;
	wpd = reshape(mx'*TD*mx,1,16); % Weights to calculate dpsi/dg
	dpsidgap = wpd*pp;
	newdrh = (psibry-wp*pp)/dpsidgap;
      else % In this case we have somehow drifted outside grid
	newdrh = 1e22; % Force a switch to interval halving.
      end
      if abs(newdrh)>abs(drh) % Diverging so switch to interval halving method
	% Reset position
	if gapspec_option == 1
	  R=gapspec(j,1); Z=gapspec(j,2); 
	else
	  R=gapspec(j,5); Z=gapspec(j,6);
	end
	drh = sign((psibry-psigap)/dpsidgap0)*mean([dr dz]); psi2 = psigap; psi1 = psigap;
	while l<30
	  l=l+1;
	  R = R+drh*ur; Z = Z+drh*uz;
	  k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
	  if min(iip)<1 | max(iip)>ngg
	    drh = -drh/2; % Try again
	    if gapspec_option == 1
	      R=gapspec(j,1); Z=gapspec(j,2); 
	    else
	      R=gapspec(j,5); Z=gapspec(j,6);
	    end
	  else
	    tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
	    wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
	    psi1 = wp*psizr(iip)';
	  end
	  if (psi1-psibry)*(psi2-psibry)<=0
	    drh = -drh/2;
	  end
	  psi2 = psi1;
	end % End of special cases handling using interval halving
      else % Normal Newton-Rhapson iteration
	drh = newdrh; R = R+drh*ur; Z = Z+drh*uz;
      end
      if drh == 0, break, end
    end % End of finding gap
    k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
    pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
    wp = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
    if gapspec_option == 2 % In this case reevaluate gr,gz and find an r,z on limiter
      wpr = reshape(mx'*[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
      wpz = reshape(mx'*[0 1 2*tz 3*tz^2]'/dz*[1 tr tr^2 tr^3]*mx,1,16);
      gr = wpr*pp; gz = wpz*pp; ur = gr/norm([gr gz]); uz = gz/norm([gr gz]);
      % Find where gr,gz intersects a limdata element
      smallestgap = 1e9;
      for k=1:nlim-1
        m = [rlimdata(k+1)-rlimdata(k) gr; zlimdata(k+1)-zlimdata(k) gz];
	if rcond(m)>0
	  kg = inv(m)*[R-rlimdata(k); Z-zlimdata(k)];
	  if kg(1)>=0 & kg(1)<=1
	    if abs(kg(2)) < smallestgap
	      gapspec(j,1) = rlimdata(k)+kg(1)*(rlimdata(k+1)-rlimdata(k));
	      gapspec(j,2) = zlimdata(k)+kg(1)*(zlimdata(k+1)-zlimdata(k));
	      smallestgap = abs(kg(2));
	    end
	  end
	end
      end
    end
    TD = [0 1 2*tz 3*tz^2]'*uz/dz*[1 tr tr^2 tr^3]+[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]*ur/dr;
    wpd = reshape(mx'*TD*mx,1,16);
    dpsidgap = wpd*pp; % How equilibrium flux changes along gap vector [gr,gz]
    dgapdpsi(j) = -1/dpsidgap; % How gap changes with dpsigap-dpsibry
    iigap(j,:) = iip; wgap(j,:) = wp;
    gaps(j,:) = [norm([R-gapspec(j,1) Z-gapspec(j,2)]) gapspec(j,1:2) R Z]; % gap, (r,z), (rs,zs)
  end
  if max(abs(idoplots)) > 0 & ~ilimited
    rdivleg = [rstrike(1+j2); gaps(ngap+1:ngap+nextragap1,4); rx; gaps(ngap+nextragap1+1:end,4); rstrike(2+j2)];
    zdivleg = [zstrike(1+j2); gaps(ngap+1:ngap+nextragap1,5); zx; gaps(ngap+nextragap1+1:end,5); zstrike(2+j2)];
  else
    rdivleg = []; zdivleg = [];
  end
  gaps = gaps(1:ngap,:); gapspec = gapspec(1:ngap,:);
  if iverbose >= 2
    disp('Volume, area, area weighted with 1/R, thermal energy, current as functions of flux');
    disp('and how these change when the flux changes, have all been calculated.');
    disp(['Vtot = ' num2str(V(end)) ' m^3'])
    disp(['Atot = ' num2str(A(end)) ' m^2'])
    disp(['Ltot = ' num2str(L(end)) ' m'])
    disp(['Wtot = ' num2str(W(end)) ' J'])
    disp(['Itot = ' num2str(I(end)) ' A'])
    disp(['betap = ' num2str(betap)])
    disp(['li = ' num2str(li)])
    if ngap > 0
      for j=1:ngap
        disp(['Gap between (r,z)=(' num2str(gaps(j,2)) ',' num2str(gaps(j,3)) ') and (r,z)=(' ...
	  num2str(gaps(j,4)) ',' num2str(gaps(j,5)) ') on the separatrix is ' num2str(gaps(j,1)) ' m']);
      end
    end
  end
  s='Finished deep geometry analysis';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  
  % Indices to variables and equations
  iused = unique([iplasma' iplasma'+1 iplasma'-1 iplasma'+nz iplasma'-nz find(V_psizr(end,:)) iix iix2 ii0]);
  if exist('iistrike','var')
    dum = iistrike(:)';
    iused = union(iused,dum(dum>0&dum<=ngg));
  end
  isopsi = zeros(niso,1);
  isobz = zeros(niso,1);
  isobr = zeros(niso,1);
  for j = 1:niso
    R = iso(j,1); Z = iso(j,2);
    k = 1+floor((R-rg(1))/dr)*nz+floor((Z-zg(1))/dz); iip = k+neighbors;
    pp = psizr(iip)'; tr = (R-rgg(k))/dr; tz = (Z-zgg(k))/dz;
    wp  = reshape(mx'*[1 tz tz^2 tz^3]'*[1 tr tr^2 tr^3]*mx,1,16);
    wpr = reshape(mx'*[1 tz tz^2 tz^3]'*[0 1 2*tr 3*tr^2]/dr*mx,1,16);
    wpz = reshape(mx'*[0 1 2*tz 3*tz^2]'/dz*[1 tr tr^2 tr^3]*mx,1,16);
    isopsi(j) = wp*pp;
    isobz(j) = wpr*pp/R;
    isobr(j) = -wpz*pp/R;
    wiso(j,:) = wp;
    wriso(j,:) = wpr;
    wziso(j,:) = wpz;
    iiiso(j,:) = iip;
    iused = union(iused,iip);
  end
  for ia = 1:na
    iused = union(iused,ib(ia)+neighbors);
  end
  iused = intersect(iused,1:ngg); % Remove bad indices (occur if jphi~=0 at edge of grid)
  nused = length(iused); nplasma = length(iplasma);
  iplasmac = find(ismember(iused,iplasma));
  iiac = find(ismember(iused,iia));
  ii0c = find(ismember(iused,ii0));
  jp = (1:nkn+2); jf = jp+nkn+2;
 
  if iverbose >= 2
    disp('Building matrix of equations for how applied flux, W(V), I(A) change when psizr, pprime, ffprim change...')
  end
  % Build matrix of equations for perturbed equilibrium (~2 s for 65x65)
  M = zeros(nused); % M = dpsizr_app/dpsizr
  % When pprime, ffprim change by spline functions this will change psizr_pla analogous to a change in psizr_app
  U = zeros(nused,jf(end)); % U = dpsizr/ds, here ds is the spline functions
  
  % Some variables to facilitate the making of M
  x = psibarzr(iplasma); a = 1-x; R = rgg(iplasma); % For more readability below
  jpla = jphi0(iplasma)/(psimag-psibry); djdpsi = djdp(iplasma);
  y = psizr(iplasma)*ones(1,nkn+2);
  m = max(1,fix(min(nkn,1+nkn*x))); % Indices to spline coefficients in iplasma
  jpp = R*ones(1,nkn+2).*(c1(m,:)+2*c2(m,:).*y+3*c3(m,:).*y.^2)*twopi;
  jff = (c1(m,:)+2*c2(m,:).*y+3*c3(m,:).*y.^2)/mu0./(R*ones(1,nkn+2))*twopi;
  
  mub = zeros(nused,na);
  for j = 1:nused
    iru = ceil(iused(j)/nz); iru1nz = (iru-1)*nz;
    for ia = 1:na
      for k=1:16
        irp = ceil((ib(ia)+neighbors(k))/nz);
        idz = 1+abs(iused(j)-ib(ia)-neighbors(k)+(irp-iru)*nz);
        coupling(k) = mpp(idz+iru1nz,irp);
      end
      mub(j,ia) = wbs(ia,:)*coupling';
    end
  end
  
  % Equations for flux change on the grid on the form dpsizr-dpsizr_pla = dpsizr_app
  % Since dpsizr_pla = Mgg*dcdpsizr*dpsizr => M = (E-Mgg*dcdpsizr) and M*dpsizr = dpsizr_app
  % The M that is created below contains subset 'iused' of the grid
  for j = 1:nused
    iru = ceil(iused(j)/nz);
    for k=1:nplasma
      irp = ceil(iplasma(k)/nz);
      idz = 1+abs(iused(j)-iplasma(k)+(irp-iru)*nz);
      coupling(k) = mpp(idz+(iru-1)*nz,irp);
    end
    M(j,iplasmac) = -dr*dz*coupling.*djdpsi';
    M(j,iiac) = M(j,iiac)+dr*dz*coupling*(a.*djdpsi+jpla)*wa;
    M(j,ii0c) = M(j,ii0c)+dr*dz*coupling*(x.*djdpsi-jpla)*w0;
    M(j,j) = M(j,j)+1;
    % How the flux changes if pprime, ffprim are changed by spline functions
    U(j,jp) = dr*dz*coupling*jpp;
    U(j,jf) = dr*dz*coupling*jff;
  end
  for ia = 1:na
    ibc = find(ismember(iused,ib(ia)+neighbors));
    M(1:nused,[ibc ii0c]) = M(1:nused,[ibc ii0c])-mub(:,ia)*[wbs(ia,:) -w0]*dibdpsi(ia);
  end

  s='System, M of equations complete';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;

  if iverbose >= 2
    disp('Solving the matrix of equations for dpsizr, dpprime, dffprim...')
  end
  % Solve equation for perturbed equilibrium
  Minv = inv(M);
  s='The M matrix is solved';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  
  % Calculate how flux responds to the spline coefficients
  dpsicds = Minv*U;
  % Calculate pinv of the response of constraints (C) to spline coefficients (s) 
  dsdC = pinv([Wn_psizr(:,iused)*dpsicds+W_g;In_psizr(:,iused)*dpsicds+I_g]);

  if iverbose >= 2
    disp('Calculating plasma response to all independent variables...')
  end
  % Now create all the response objects
  xmats = zeros(nss,nss); % Will contain extra coupling between conductors caused by plasma response
  dcphidis = zeros(ngg,nss); % Will contain how cphi is affected by change of coil and vessel currents
  dPkn = zeros(nz,nr); % Pressure change on grid due to spline change of pres
  dPprime = zeros(nz,nr); % pprime change on grid due to spline change of pres
  dFFprim = zeros(nz,nr); % ffprim change on grid due to spline change of f^2/2
  mg = fix(min(nkn,1+nkn*linspace(0,1,nr)))'; % Indices to spline coefficients
  dLdis = zeros(nr,nss); dAdis = zeros(nr,nss); dVdis = zeros(nr,nss);
  dWdis = zeros(nr,nss); dIdis = zeros(nr,nss); dWndis = zeros(nr,nss); dIndis = zeros(nr,nss);
  dpprimedis = zeros(nr,nss); dffprimdis = zeros(nr,nss);
  drqdis = zeros(na*nq,nss);
  s='Memory was allocated';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  
  if options.iconstraints == 3
    kloop=[-2*nr-2:-3 1:nss]; % Do profile and Is responses
  else
    kloop=-2:nss; % Do Wth/betap, li, Ip responses
  end
  dpsizr = 0*psizr;
  
  dpsiappc = zeros(nused,1); % Change in applied flux, compressed format, i.e. only containing iused
  dpsic = zeros(nused,1); % Change in flux, compressed format, i.e. only containing iused
  for k = kloop
    if iverbose >= 2
      if k == kloop(1)
        disp('Beginning with response to profile parameters...')
      end
      if k == 1
        disp('Continuing with response to conductors...')
      end
    end
    dWntarget = W*0;
    dIntarget = I*0;
    if     k< -2 % response to spline coefficients
      ds = dsdC(:,k+2*nr+3);
    else
      if k==-2 % response to betap and thermal energy
        dWntarget = W/W(end); % Perturb thermal energy profile evenly
	if isfield(options,'dWndbetap') % Use recommended variation of thermal energy profile
          dWntarget = options.dWndbetap;
	end
	if isfield(options,'dIndbetap') % Use recommended variation of current profile
          dIntarget = options.dIndbetap;
	end
	if options.iconstraints == 2
	  if isfield(options,'dWndw') % Use recommended variation of thermal energy profile
            dWntarget = options.dWndw;
	  end
	  if isfield(options,'dIndw') % Use recommended variation of current profile
            dIntarget = options.dIndw;
	  end
	end
      elseif k==-1 % response to li
	dIntarget = I.*(I-I(end))/I(end)^2; % Change peaking of current profile
	if isfield(options,'dWndli') % Use recommended variation of thermal energy profile
          dWntarget = options.dWndli;
	end
	if isfield(options,'dIndli') % Use recommended variation of current profile
          dIntarget = options.dIndli;
	end
      elseif k== 0 % response to Ip
	dIntarget = I/I(end); % Perturb current profile evenly
	if isfield(options,'dWndip') % Use recommended variation of thermal energy profile
          dWntarget = options.dWndip;
	end
	if isfield(options,'dIndip') % Use recommended variation of current profile
          dIntarget = options.dIndip;
	end
      elseif k<=ncc % response to cc
	dpsiappc = mpc(iused,k);
      elseif k<=ncc+nvv % response to vv
	dpsiappc = mpv(iused,k-ncc);
      else
	dpsiappc = mpt(iused,k-ncc-nvv);
      end
      dpsic = Minv*dpsiappc;    
      ds = dsdC*[dWntarget-Wn_psizr(:,iused)*dpsic;dIntarget-In_psizr(:,iused)*dpsic];
    end
    p0 = c0*ds(jp); p1 = c1*ds(jp); p2 = c2*ds(jp); p3 = c3*ds(jp);
    f0 = c0*ds(jf); f1 = c1*ds(jf); f2 = c2*ds(jf); f3 = c3*ds(jf);
    dpsizr(iused) = dpsic+dpsicds*ds;
    dpsipla = dpsizr(iplasma)'*cphi(iplasma)/sumcphi;
    dpsimag = dpsizr(iia)*wa'; dpsibry = dpsizr(ii0)*w0';
    dpprime = (p1(mg)+2*p2(mg).*psigrid+3*p3(mg).*psigrid.^2)*twopi-pprime*(dpsimag-dpsibry)/(psimag-psibry);
    dffprim = (f1(mg)+2*f2(mg).*psigrid+3*f3(mg).*psigrid.^2)*twopi-ffprim*(dpsimag-dpsibry)/(psimag-psibry);
    dfpol = (f0(mg)+f1(mg).*psigrid+f2(mg).*psigrid.^2+f3(mg).*psigrid.^3)./fpol;
    dPkn(iplasma) = p0(m)+p1(m).*psizr(iplasma)+p2(m).*psizr(iplasma).^2+p3(m).*psizr(iplasma).^3;
    dPprime(iplasma) = (p1(m)+2*p2(m).*psizr(iplasma)+3*p3(m).*psizr(iplasma).^2)*twopi;
    dFFprim(iplasma) = (f1(m)+2*f2(m).*psizr(iplasma)+3*f3(m).*psizr(iplasma).^2)*twopi;
    dcphi = (djdp.*(dpsizr-dpsibry*psibarzr-dpsimag*(1-psibarzr))-...
            jphi0*(dpsimag-dpsibry)/(psimag-psibry)+rgg.*dPprime+dFFprim/mu0./rgg)*dr*dz;
    drhob = rhob_psizr*dpsizr(:);
    for ia=1:na
      dcphi(ib(ia)+neighbors) = dcphi(ib(ia)+neighbors)+didrhob(ia)*drhob(ia)*wbs(ia,:);
    end
    dL = L_psizr*dpsizr(:);
    dA = A_psizr*dpsizr(:);
    dV = V_psizr*dpsizr(:);
    dW = W_psizr*dpsizr(:)+W_g*ds;
    dI = I_psizr*dpsizr(:)+I_g*ds;
    dWn = Wn_psizr*dpsizr(:)+W_g*ds;
    dIn = In_psizr*dpsizr(:)+I_g*ds;
    dLprime = (spline(psigrid,dL,psigrid+1e-6)-spline(psigrid,dL,psigrid-1e-6))*pi*1e6-Lprime*(dpsimag-dpsibry)/(psimag-psibry);
    dqpsi = qpsi.*(dLprime./Lprime+dfpol./fpol);
    if nq>0
      if ~isnan(dqpsi)
	dqpsiq = spline(psigrid,dqpsi,psiq); % How much q changed at the original normalized flux of the q surfaces
      else
	dqpsiq = NaN*psiq;
      end
      for j = 1:nq
	drhoq(:,j) = rhoq_psizr((j-1)*na+(1:na),:)*dpsizr(:)-dqpsiq(j)./dqdrho(:,j); % The new rho for the q
	drq(:,j) = drhoq(:,j).*cos(ths)'; dzq(:,j) = drhoq(:,j).*sin(ths)';
      end
    end
    if ngap>0
      for j = 1:ngap
        dgap(j,1) = (dpsizr(iigap(j,:))*wgap(j,:)'-dpsibry)*dgapdpsi(j);
      end
    else
      dgap = zeros(0,1);
    end
    if niso>0
      for j = 1:niso
	disopsi(j,1) = dpsizr(iiiso(j,:))*wiso(j,:)';
	disobz(j,1) = dpsizr(iiiso(j,:))*wriso(j,:)'/iso(j,1);
	disobr(j,1) =-dpsizr(iiiso(j,:))*wziso(j,:)'/iso(j,1);
      end
    else
      disopsi = zeros(0,1);
      disobz = zeros(0,1);
      disobr = zeros(0,1);
    end    
    dpsizr_r = [zeros(nz,1) dpsizr(:,3:end)-dpsizr(:,1:end-2) zeros(nz,1)]/2/dr;
    dpsizr_z = [zeros(1,nr);dpsizr(3:end,:)-dpsizr(1:end-2,:);zeros(1,nr)]/2/dz;
    ddrsep = (dpsizr(iix2)*wx2'-dpsizr(iix)*wx')*drsepdpsi+drsep/drsepdpsi*d2rsepdpsi2*dpsizr(iisep)*wsep';
    for j = 1:4
      if ~isnan(zstrike(j))
        drstrike(j) = drstrikedpsi(j)*dpsizr(iistrike(j,:))*wstrike(j,:)';
        dzstrike(j) = dzstrikedpsi(j)*dpsizr(iistrike(j,:))*wstrike(j,:)';
      end
    end
    cx = xshift_Bx*[dpsizr(iix)*wxr'; dpsizr(iix)*wxz'];
    cx2 = x2shift_Bx*[dpsizr(iix2)*wx2r'; dpsizr(iix2)*wx2z'];
    if zx>za
      drx = [cx2(1); cx(1)]; dzx = [cx2(2); cx(2)];
    else
      drx = [cx(1); cx2(1)]; dzx = [cx(2); cx2(2)];
    end

    if ilimited
      dlim = -dpsizr(iilim)*wld'/psilimbis*ulim; dr0 = dlim(1); dz0 = dlim(2);
    else
      dr0 = cx(1); dz0 = cx(2);
    end

    % Calculate change of boundary contour.
    dVedge = dVedgedrho'.*drhob;
    drb = drhob.*cos(ths'); drb(1) = dr0; dzb = drhob.*sin(ths'); dzb(1) = dz0;
    dDX = diff(drb([1:na 1]))'; dDY = diff(dzb([1:na 1]))';
    dCl = sum((DX.*dDX+DY.*dDY)./cpieces); % Change of contour length
    % Change of betap and li
    dbetap = betap * (dW(end)/W(end) - dV(end)/V(end) - 2*dI(end)/cpasma + 2*dCl/Cl); % Due to dWth, dIp and change of contour length
    dBp2V = 2*sum((psizr_r(iplasma).*dpsizr_r(iplasma)+psizr_z(iplasma).*dpsizr_z(iplasma))./rgg(iplasma))/twopi*dr*dz+...
            Bp2edge*dVedge;
    dli = li * (dBp2V / Bp2V - dV(end)/V(end) - 2*dI(end)/cpasma + 2*dCl/Cl);
    
    if    k < -2-nr % Response to thermal energy profile details
      kk = k-kloop(1)+1;
      dcphidW(:,kk) = dcphi(:);
      drdW(kk) = (sum(rgg(:).*dcphi(:))-rcur*sum(dcphi(:)))/sumcphi;
      dzdW(kk) = (sum(zgg(:).*dcphi(:))-zcur*sum(dcphi(:)))/sumcphi;
      dpsipladW(kk) = dpsipla;
      dpsimagdW(kk) = dpsimag;
      dpsibrydW(kk) = dpsibry;
      dlidW(kk) = dli; % li is an output when contraints.ichoice == 3
      dbetapdW(kk) = dbetap; % betap is an output when contraints.ichoice == 3
      dLdW(:,kk) = dL; dAdW(:,kk) = dA; dVdW(:,kk) = dV; dIdW(:,kk) = dI; dWdW(:,kk) = dW; dIndW(:,kk) = dIn; dWndW(:,kk) = dWn;
      dpprimedW(:,kk) = dpprime;
      dffprimdW(:,kk) = dffprim;
      dqpsidW(:,kk) = dqpsi;
      drqdW(:,kk) = drq(:);
      dzqdW(:,kk) = dzq(:);
      drbdW(:,kk) = drb;
      dzbdW(:,kk) = dzb;
      ddrsepdW(kk) = ddrsep;
      drstrikedW(:,kk) = drstrike;
      dzstrikedW(:,kk) = dzstrike;
      drxdW(:,kk) = drx;
      dzxdW(:,kk) = dzx;
      dgapdW(:,kk) = dgap;
      disopsidW(:,kk) = disopsi;
      disobzdW(:,kk) = disobz;
      disobrdW(:,kk) = disobr;
    elseif k <  -2 % Response to current profile details
      kk = k-kloop(1)+1-nr;
      dcphidI(:,kk) = dcphi(:);
      drdI(kk) = (sum(rgg(:).*dcphi(:))-rcur*sum(dcphi(:)))/sumcphi;
      dzdI(kk) = (sum(zgg(:).*dcphi(:))-zcur*sum(dcphi(:)))/sumcphi;
      dpsipladI(kk) = dpsipla;
      dpsimagdI(kk) = dpsimag;
      dpsibrydI(kk) = dpsibry;
      dlidI(kk) = dli;
      dbetapdI(kk) = dbetap;
      dLdI(:,kk) = dL; dAdI(:,kk) = dA; dVdI(:,kk) = dV; dIdI(:,kk) = dI; dWdI(:,kk) = dW; dIndI(:,kk) = dIn; dWndI(:,kk) = dWn;
      dpprimedI(:,kk) = dpprime;
      dffprimdI(:,kk) = dffprim;
      dqpsidI(:,kk) = dqpsi;
      drqdI(:,kk) = drq(:);
      dzqdI(:,kk) = dzq(:);
      drbdI(:,kk) = drb;
      dzbdI(:,kk) = dzb;
      ddrsepdI(kk) = ddrsep;
      drstrikedI(:,kk) = drstrike;
      dzstrikedI(:,kk) = dzstrike;
      drxdI(:,kk) = drx;
      dzxdI(:,kk) = dzx;
      dgapdI(:,kk) = dgap;
      disopsidI(:,kk) = disopsi;
      disobzdI(:,kk) = disobz;
      disobrdI(:,kk) = disobr;
    elseif k == -2 % Thermal energy and betap response (this perturbation also changes li)
      dcphi1 = dcphi;
      dpsipla1 = dpsipla;
      dpsimag1 = dpsimag;
      dpsibry1 = dpsibry;
      dL1 = dL; dA1 = dA; dV1 = dV; dI1 = dI; dW1 = dW; dIn1 = dIn; dWn1 = dWn;
      dpprime1 = dpprime;
      dffprim1 = dffprim;
      dli1 = dli;
      dbetap1 = dbetap;
      dqpsi1 = dqpsi;
      drq1 = drq; dzq1 = dzq;
      drb1 = drb; dzb1 = dzb;
      ddrsep1 = ddrsep; drstrike1 = drstrike; dzstrike1 = dzstrike;
      drx1 = drx; dzx1 = dzx;
      dgap1 = dgap;
      disopsi1 = disopsi;
      disobz1 = disobz;
      disobr1 = disobr;
    elseif k == -1 % li response (this perturbation also changes betap)
      dcphi2 = dcphi;
      dpsipla2 = dpsipla;
      dpsimag2 = dpsimag;
      dpsibry2 = dpsibry;
      dL2 = dL; dA2 = dA; dV2 = dV; dI2 = dI; dW2 = dW; dIn2 = dIn; dWn2 = dWn;
      dpprime2 = dpprime;
      dffprim2 = dffprim;
      dli2 = dli;
      dbetap2 = dbetap;
      dqpsi2 = dqpsi;
      drq2 = drq; dzq2 = dzq;
      drb2 = drb; dzb2 = dzb;
      ddrsep2 = ddrsep; drstrike2 = drstrike; dzstrike2 = dzstrike;
      drx2 = drx; dzx2 = dzx;
      dgap2 = dgap;
      disopsi2 = disopsi;
      disobz2 = disobz;
      disobr2 = disobr;
    elseif k == 0 % Ip response (this perturbation also changes betap and li)
      % We have now made 3 perturbations with dpsizr_app=0. Sort out dependencies on betap or Wth and li, Ip
      if options.iconstraints == 1 
        H = inv([dbetap1 dli1 dI1(end); dbetap2 dli2 dI2(end); dbetap dli dI(end)]);
	dcphidbetap = H(1,1)*dcphi1+H(1,2)*dcphi2+H(1,3)*dcphi;
        drdbetap = (sum(rgg(:).*dcphidbetap(:))-rcur*sum(dcphidbetap(:)))/sumcphi;
        dzdbetap = (sum(zgg(:).*dcphidbetap(:))-zcur*sum(dcphidbetap(:)))/sumcphi;
	dpsipladbetap = H(1,1)*dpsipla1+H(1,2)*dpsipla2+H(1,3)*dpsipla;
	dpsimagdbetap = H(1,1)*dpsimag1+H(1,2)*dpsimag2+H(1,3)*dpsimag;
	dpsibrydbetap = H(1,1)*dpsibry1+H(1,2)*dpsibry2+H(1,3)*dpsibry;
	dLdbetap = H(1,1)*dL1+H(1,2)*dL2+H(1,3)*dL;
	dAdbetap = H(1,1)*dA1+H(1,2)*dA2+H(1,3)*dA;
	dVdbetap = H(1,1)*dV1+H(1,2)*dV2+H(1,3)*dV;
	dIdbetap = H(1,1)*dI1+H(1,2)*dI2+H(1,3)*dI;
	dWdbetap = H(1,1)*dW1+H(1,2)*dW2+H(1,3)*dW;
	dIndbetap = H(1,1)*dIn1+H(1,2)*dIn2+H(1,3)*dIn;
	dWndbetap = H(1,1)*dWn1+H(1,2)*dWn2+H(1,3)*dWn;
	dpprimedbetap = H(1,1)*dpprime1+H(1,2)*dpprime2+H(1,3)*dpprime;
	dffprimdbetap = H(1,1)*dffprim1+H(1,2)*dffprim2+H(1,3)*dffprim;
	dqpsidbetap = H(1,1)*dqpsi1+H(1,2)*dqpsi2+H(1,3)*dqpsi;
	drqdbetap = H(1,1)*drq1(:)+H(1,2)*drq2(:)+H(1,3)*drq(:);
	dzqdbetap = H(1,1)*dzq1(:)+H(1,2)*dzq2(:)+H(1,3)*dzq(:);
	drbdbetap = H(1,1)*drb1+H(1,2)*drb2+H(1,3)*drb;
	dzbdbetap = H(1,1)*dzb1+H(1,2)*dzb2+H(1,3)*dzb;
	ddrsepdbetap = H(1,1)*ddrsep1+H(1,2)*ddrsep2+H(1,3)*ddrsep;
	drstrikedbetap = H(1,1)*drstrike1+H(1,2)*drstrike2+H(1,3)*drstrike;
	dzstrikedbetap = H(1,1)*dzstrike1+H(1,2)*dzstrike2+H(1,3)*dzstrike;
	drxdbetap = H(1,1)*drx1+H(1,2)*drx2+H(1,3)*drx;
	dzxdbetap = H(1,1)*dzx1+H(1,2)*dzx2+H(1,3)*dzx;
	dgapdbetap = H(1,1)*dgap1+H(1,2)*dgap2+H(1,3)*dgap;
	disopsidbetap = H(1,1)*disopsi1+H(1,2)*disopsi2+H(1,3)*disopsi;
	disobzdbetap = H(1,1)*disobz1+H(1,2)*disobz2+H(1,3)*disobz;
	disobrdbetap = H(1,1)*disobr1+H(1,2)*disobr2+H(1,3)*disobr;
      elseif options.iconstraints == 2
        H = inv([dW1(end) dli1 dI1(end); dW2(end) dli2 dI2(end); dW(end) dli dI(end)]);
	dcphidw = H(1,1)*dcphi1+H(1,2)*dcphi2+H(1,3)*dcphi;
        drdw = (sum(rgg(:).*dcphidw(:))-rcur*sum(dcphidw(:)))/sumcphi;
        dzdw = (sum(zgg(:).*dcphidw(:))-zcur*sum(dcphidw(:)))/sumcphi;
	dpsipladw = H(1,1)*dpsipla1+H(1,2)*dpsipla2+H(1,3)*dpsipla;
	dpsimagdw = H(1,1)*dpsimag1+H(1,2)*dpsimag2+H(1,3)*dpsimag;
	dpsibrydw = H(1,1)*dpsibry1+H(1,2)*dpsibry2+H(1,3)*dpsibry;
	dLdw = H(1,1)*dL1+H(1,2)*dL2+H(1,3)*dL;
	dAdw = H(1,1)*dA1+H(1,2)*dA2+H(1,3)*dA;
	dVdw = H(1,1)*dV1+H(1,2)*dV2+H(1,3)*dV;
	dIdw = H(1,1)*dI1+H(1,2)*dI2+H(1,3)*dI;
	dWdw = H(1,1)*dW1+H(1,2)*dW2+H(1,3)*dW;
	dIndw = H(1,1)*dIn1+H(1,2)*dIn2+H(1,3)*dIn;
	dWndw = H(1,1)*dWn1+H(1,2)*dWn2+H(1,3)*dWn;
	dpprimedw = H(1,1)*dpprime1+H(1,2)*dpprime2+H(1,3)*dpprime;
	dffprimdw = H(1,1)*dffprim1+H(1,2)*dffprim2+H(1,3)*dffprim;
	dqpsidw = H(1,1)*dqpsi1+H(1,2)*dqpsi2+H(1,3)*dqpsi;
	drqdw = H(1,1)*drq1(:)+H(1,2)*drq2(:)+H(1,3)*drq(:);
	dzqdw = H(1,1)*dzq1(:)+H(1,2)*dzq2(:)+H(1,3)*dzq(:);
	drbdw = H(1,1)*drb1+H(1,2)*drb2+H(1,3)*drb;
	dzbdw = H(1,1)*dzb1+H(1,2)*dzb2+H(1,3)*dzb;
	ddrsepdw = H(1,1)*ddrsep1+H(1,2)*ddrsep2+H(1,3)*ddrsep;
	drstrikedw = H(1,1)*drstrike1+H(1,2)*drstrike2+H(1,3)*drstrike;
	dzstrikedw = H(1,1)*dzstrike1+H(1,2)*dzstrike2+H(1,3)*dzstrike;
	drxdw = H(1,1)*drx1+H(1,2)*drx2+H(1,3)*drx;
	dzxdw = H(1,1)*dzx1+H(1,2)*dzx2+H(1,3)*dzx;
	dgapdw = H(1,1)*dgap1+H(1,2)*dgap2+H(1,3)*dgap;
	disopsidw = H(1,1)*disopsi1+H(1,2)*disopsi2+H(1,3)*disopsi;
	disobzdw = H(1,1)*disobz1+H(1,2)*disobz2+H(1,3)*disobz;
	disobrdw = H(1,1)*disobr1+H(1,2)*disobr2+H(1,3)*disobr;
      end
      
      dcphidli = H(2,1)*dcphi1+H(2,2)*dcphi2+H(2,3)*dcphi;
      drdli = (sum(rgg(:).*dcphidli(:))-rcur*sum(dcphidli(:)))/sumcphi;
      dzdli = (sum(zgg(:).*dcphidli(:))-zcur*sum(dcphidli(:)))/sumcphi;
      dpsipladli = H(2,1)*dpsipla1+H(2,2)*dpsipla2+H(2,3)*dpsipla;
      dpsimagdli = H(2,1)*dpsimag1+H(2,2)*dpsimag2+H(2,3)*dpsimag;
      dpsibrydli = H(2,1)*dpsibry1+H(2,2)*dpsibry2+H(2,3)*dpsibry;
      dLdli = H(2,1)*dL1+H(2,2)*dL2+H(2,3)*dL;
      dAdli = H(2,1)*dA1+H(2,2)*dA2+H(2,3)*dA;
      dVdli = H(2,1)*dV1+H(2,2)*dV2+H(2,3)*dV;
      dIdli = H(2,1)*dI1+H(2,2)*dI2+H(2,3)*dI;
      dWdli = H(2,1)*dW1+H(2,2)*dW2+H(2,3)*dW;
      dIndli = H(2,1)*dIn1+H(2,2)*dIn2+H(2,3)*dIn;
      dWndli = H(2,1)*dWn1+H(2,2)*dWn2+H(2,3)*dWn;
      dpprimedli = H(2,1)*dpprime1+H(2,2)*dpprime2+H(2,3)*dpprime;
      dffprimdli = H(2,1)*dffprim1+H(2,2)*dffprim2+H(2,3)*dffprim;
      dqpsidli = H(2,1)*dqpsi1+H(2,2)*dqpsi2+H(2,3)*dqpsi;
      drqdli = H(2,1)*drq1(:)+H(2,2)*drq2(:)+H(2,3)*drq(:);
      dzqdli = H(2,1)*dzq1(:)+H(2,2)*dzq2(:)+H(2,3)*dzq(:);
      drbdli = H(2,1)*drb1+H(2,2)*drb2+H(2,3)*drb;
      dzbdli = H(2,1)*dzb1+H(2,2)*dzb2+H(2,3)*dzb;
      ddrsepdli = H(2,1)*ddrsep1+H(2,2)*ddrsep2+H(2,3)*ddrsep;
      drstrikedli = H(2,1)*drstrike1+H(2,2)*drstrike2+H(2,3)*drstrike;
      dzstrikedli = H(2,1)*dzstrike1+H(2,2)*dzstrike2+H(2,3)*dzstrike;
      drxdli = H(2,1)*drx1+H(2,2)*drx2+H(2,3)*drx;
      dzxdli = H(2,1)*dzx1+H(2,2)*dzx2+H(2,3)*dzx;
      dgapdli = H(2,1)*dgap1+H(2,2)*dgap2+H(2,3)*dgap;
      disopsidli = H(2,1)*disopsi1+H(2,2)*disopsi2+H(2,3)*disopsi;
      disobzdli = H(2,1)*disobz1+H(2,2)*disobz2+H(2,3)*disobz;
      disobrdli = H(2,1)*disobr1+H(2,2)*disobr2+H(2,3)*disobr;

      dcphidip = H(3,1)*dcphi1+H(3,2)*dcphi2+H(3,3)*dcphi;
      drdip = (sum(rgg(:).*dcphidip(:))-rcur*sum(dcphidip(:)))/sumcphi;
      dzdip = (sum(zgg(:).*dcphidip(:))-zcur*sum(dcphidip(:)))/sumcphi;
      dpsipladip = H(3,1)*dpsipla1+H(3,2)*dpsipla2+H(3,3)*dpsipla;
      dpsimagdip = H(3,1)*dpsimag1+H(3,2)*dpsimag2+H(3,3)*dpsimag;
      dpsibrydip = H(3,1)*dpsibry1+H(3,2)*dpsibry2+H(3,3)*dpsibry;
      dLdip = H(3,1)*dL1+H(3,2)*dL2+H(3,3)*dL;
      dAdip = H(3,1)*dA1+H(3,2)*dA2+H(3,3)*dA;
      dVdip = H(3,1)*dV1+H(3,2)*dV2+H(3,3)*dV;
      dIdip = H(3,1)*dI1+H(3,2)*dI2+H(3,3)*dI;
      dWdip = H(3,1)*dW1+H(3,2)*dW2+H(3,3)*dW;
      dIndip = H(3,1)*dIn1+H(3,2)*dIn2+H(3,3)*dIn;
      dWndip = H(3,1)*dWn1+H(3,2)*dWn2+H(3,3)*dWn;
      dpprimedip = H(3,1)*dpprime1+H(3,2)*dpprime2+H(3,3)*dpprime;
      dffprimdip = H(3,1)*dffprim1+H(3,2)*dffprim2+H(3,3)*dffprim;
      dqpsidip = H(3,1)*dqpsi1+H(3,2)*dqpsi2+H(3,3)*dqpsi;
      drqdip = H(3,1)*drq1(:)+H(3,2)*drq2(:)+H(3,3)*drq(:);
      dzqdip = H(3,1)*dzq1(:)+H(3,2)*dzq2(:)+H(3,3)*dzq(:);
      drbdip = H(3,1)*drb1+H(3,2)*drb2+H(3,3)*drb;
      dzbdip = H(3,1)*dzb1+H(3,2)*dzb2+H(3,3)*dzb;
      ddrsepdip = H(3,1)*ddrsep1+H(3,2)*ddrsep2+H(3,3)*ddrsep;
      drstrikedip = H(3,1)*drstrike1+H(3,2)*drstrike2+H(3,3)*drstrike;
      dzstrikedip = H(3,1)*dzstrike1+H(3,2)*dzstrike2+H(3,3)*dzstrike;
      drxdip = H(3,1)*drx1+H(3,2)*drx2+H(3,3)*drx;
      dzxdip = H(3,1)*dzx1+H(3,2)*dzx2+H(3,3)*dzx;
      dgapdip = H(3,1)*dgap1+H(3,2)*dgap2+H(3,3)*dgap;
      disopsidip = H(3,1)*disopsi1+H(3,2)*disopsi2+H(3,3)*disopsi;
      disobzdip = H(3,1)*disobz1+H(3,2)*disobz2+H(3,3)*disobz;
      disobrdip = H(3,1)*disobr1+H(3,2)*disobr2+H(3,3)*disobr;
      dpsizrdip = reshape(dpsizr, [], 1);
    elseif k > 0 % Is response
      if options.iconstraints == 1 % Perturbation that leaves betap, li, Ip unaltered
	dcphi = dcphi - dcphidbetap*dbetap-dcphidli*dli-dcphidip*dI(end);
	dpsipladis(k) = dpsipla - dpsipladbetap*dbetap-dpsipladli*dli-dpsipladip*dI(end);
	dpsimagdis(k) = dpsimag - dpsimagdbetap*dbetap-dpsimagdli*dli-dpsimagdip*dI(end);
	dpsibrydis(k) = dpsibry - dpsibrydbetap*dbetap-dpsibrydli*dli-dpsibrydip*dI(end);
        dLdis(:,k) = dL - dLdbetap*dbetap-dLdli*dli-dLdip*dI(end);
        dAdis(:,k) = dA - dAdbetap*dbetap-dAdli*dli-dAdip*dI(end);
        dVdis(:,k) = dV - dVdbetap*dbetap-dVdli*dli-dVdip*dI(end);
        dIdis(:,k) = dI - dIdbetap*dbetap-dIdli*dli-dIdip*dI(end);
        dWdis(:,k) = dW - dWdbetap*dbetap-dWdli*dli-dWdip*dI(end);
        dIndis(:,k) = dIn - dIndbetap*dbetap-dIndli*dli-dIndip*dI(end);
        dWndis(:,k) = dWn - dWndbetap*dbetap-dWndli*dli-dWndip*dI(end);
        dpprimedis(:,k) = dpprime - dpprimedbetap*dbetap-dpprimedli*dli-dpprimedip*dI(end);
        dffprimdis(:,k) = dffprim - dffprimdbetap*dbetap-dffprimdli*dli-dffprimdip*dI(end);
        dqpsidis(:,k) = dqpsi - dqpsidbetap*dbetap-dqpsidli*dli-dqpsidip*dI(end);
        drqdis(:,k) = drq(:) - drqdbetap*dbetap-drqdli*dli-drqdip*dI(end);
        dzqdis(:,k) = dzq(:) - dzqdbetap*dbetap-dzqdli*dli-dzqdip*dI(end);
	drbdis(:,k) = drb - drbdbetap*dbetap-drbdli*dli-drbdip*dI(end);
	dzbdis(:,k) = dzb - dzbdbetap*dbetap-dzbdli*dli-dzbdip*dI(end);
	ddrsepdis(:,k) = ddrsep - ddrsepdbetap*dbetap-ddrsepdli*dli-ddrsepdip*dI(end);
	drstrikedis(:,k) = drstrike - drstrikedbetap*dbetap-drstrikedli*dli-drstrikedip*dI(end);
	dzstrikedis(:,k) = dzstrike - dzstrikedbetap*dbetap-dzstrikedli*dli-dzstrikedip*dI(end);
	drxdis(:,k) = drx - drxdbetap*dbetap-drxdli*dli-drxdip*dI(end);
	dzxdis(:,k) = dzx - dzxdbetap*dbetap-dzxdli*dli-dzxdip*dI(end);
	dgapdis(:,k) = dgap - dgapdbetap*dbetap-dgapdli*dli-dgapdip*dI(end);
	disopsidis(:,k) = disopsi - disopsidbetap*dbetap-disopsidli*dli-disopsidip*dI(end);
	disobzdis(:,k) = disobz - disobzdbetap*dbetap-disobzdli*dli-disobzdip*dI(end);
	disobrdis(:,k) = disobr - disobrdbetap*dbetap-disobrdli*dli-disobrdip*dI(end);
  dpsizrdis(:,k) = reshape(dpsizr, [], 1);
      elseif options.iconstraints == 2 % Perturbation that leaves Wth, li, Ip unaltered
	dcphi = dcphi - dcphidw*dW(end)-dcphidli*dli-dcphidip*dI(end);
	dpsipladis(k) = dpsipla - dpsipladw*dW(end)-dpsipladli*dli-dpsipladip*dI(end);
	dpsimagdis(k) = dpsimag - dpsimagdw*dW(end)-dpsimagdli*dli-dpsimagdip*dI(end);
	dpsibrydis(k) = dpsibry - dpsibrydw*dW(end)-dpsibrydli*dli-dpsibrydip*dI(end);
        dLdis(:,k) = dL - dLdw*dW(end)-dLdli*dli-dLdip*dI(end);
        dAdis(:,k) = dA - dAdw*dW(end)-dAdli*dli-dAdip*dI(end);
        dVdis(:,k) = dV - dVdw*dW(end)-dVdli*dli-dVdip*dI(end);
        dIdis(:,k) = dI - dIdw*dW(end)-dIdli*dli-dIdip*dI(end);
        dWdis(:,k) = dW - dWdw*dW(end)-dWdli*dli-dWdip*dI(end);
        dIndis(:,k) = dIn - dIndw*dW(end)-dIndli*dli-dIndip*dI(end);
        dWndis(:,k) = dWn - dWndw*dW(end)-dWndli*dli-dWndip*dI(end);
        dpprimedis(:,k) = dpprime - dpprimedw*dW(end)-dpprimedli*dli-dpprimedip*dI(end);
        dffprimdis(:,k) = dffprim - dffprimdw*dW(end)-dffprimdli*dli-dffprimdip*dI(end);
        dqpsidis(:,k) = dqpsi - dqpsidw*dW(end)-dqpsidli*dli-dqpsidip*dI(end);
        drqdis(:,k) = drq(:) - drqdw*dW(end)-drqdli*dli-drqdip*dI(end);
        dzqdis(:,k) = dzq(:) - dzqdw*dW(end)-dzqdli*dli-dzqdip*dI(end);
	drbdis(:,k) = drb - drbdw*dW(end)-drbdli*dli-drbdip*dI(end);
	dzbdis(:,k) = dzb - dzbdw*dW(end)-dzbdli*dli-dzbdip*dI(end);
	ddrsepdis(:,k) = ddrsep - ddrsepdw*dW(end)-ddrsepdli*dli-ddrsepdip*dI(end);
	drstrikedis(:,k) = drstrike - drstrikedw*dW(end)-drstrikedli*dli-drstrikedip*dI(end);
	dzstrikedis(:,k) = dzstrike - dzstrikedw*dW(end)-dzstrikedli*dli-dzstrikedip*dI(end);
	drxdis(:,k) = drx - drxdw*dW(end)-drxdli*dli-drxdip*dI(end);
	dzxdis(:,k) = dzx - dzxdw*dW(end)-dzxdli*dli-dzxdip*dI(end);
	dgapdis(:,k) = dgap - dgapdw*dW(end)-dgapdli*dli-dgapdip*dI(end);
	disopsidis(:,k) = disopsi - disopsidw*dW(end)-disopsidli*dli-disopsidip*dI(end);
	disobzdis(:,k) = disobz - disobzdw*dW(end)-disobzdli*dli-disobzdip*dI(end);
	disobrdis(:,k) = disobr - disobrdw*dW(end)-disobrdli*dli-disobrdip*dI(end);
      elseif options.iconstraints == 3 % Perturbation that leaves Wth, I unaltered
	dpsipladis(k) = dpsipla;
	dpsimagdis(k) = dpsimag;
	dpsibrydis(k) = dpsibry;
	dbetapdis(k) = dbetap;
	dlidis(k) = dli;
        dLdis(:,k) = dL;
        dAdis(:,k) = dA;
        dVdis(:,k) = dV;
        dIdis(:,k) = dI;
        dWdis(:,k) = dW;
        dIndis(:,k) = dIn;
        dWndis(:,k) = dWn;
        dpprimedis(:,k) = dpprime;
        dffprimdis(:,k) = dffprim;
        dqpsidis(:,k) = dqpsi;
        drqdis(:,k) = drq(:);
        dzqdis(:,k) = dzq(:);
	drbdis(:,k) = drb;
	dzbdis(:,k) = dzb;
	ddrsepdis(:,k) = ddrsep;
	drstrikedis(:,k) = drstrike;
	dzstrikedis(:,k) = dzstrike;
	drxdis(:,k) = drx;
	dzxdis(:,k) = dzx;
	dgapdis(:,k) = dgap;
	disopsidis(:,k) = disopsi;
	disobzdis(:,k) = disobz;
	disobrdis(:,k) = disobr;
      end
      xmats(1:ncc,k) = mpc'*dcphi(:);
      xmats(1+ncc:ncc+nvv,k) = mpv'*dcphi(:);
      xmats(1+ncc+nvv:ncc+nvv+ntd,k) = mpt'*dcphi(:);
      drdis(k) = sum(rgg(:).*dcphi(:))/sumcphi;
      dzdis(k) = sum(zgg(:).*dcphi(:))/sumcphi;
      dcphidis(:,k) = dcphi(:);
    end    
    s=['Response calculated for k=' num2str(k)];
    mexec(end+1,1:length(s)) = s;
    texec(end+1) = (now-t0)*secperday;
  end % End of k loop for creating response objects
  
  if iverbose >= 2
    disp('Analyzing vertical stability:')
  end
  % Calculate vertical growthrate, i.e. mode with highest growth rate of conductor currents
  rss = diag([resc;resv;rest]);
  lstar = (mss+xmats+mss'+xmats')/2;
  % Now do any desired removal of conductor elements as described by idxcc, idxvv, idxtd
  idxss = [idxcc ncc+idxvv ncc+nvv+idxtd]; % indices of elements to keep
  rssx = rss(idxss,idxss);
  lstarx = lstar(idxss,idxss);
  lstari = inv(lstarx);
  % Stability margin (Portone form; cf NF 45 (2005) 926):
  tmp = -inv(mss(idxss,idxss))*lstarx;
  d = eigsort(tmp);
  m_s = d(1);
  amat = -lstari*rssx;
  [vecs,vals] = eigsort(amat);
  gamma = vals(1);
  if iverbose > 0
    disp(['Stability margin = ' num2str(m_s)])
   % disp(['High passive root = ' num2str(real(vals(1))) ' + i' num2str(imag(vals(1)))])
    disp(['gamma_z = ' num2str(gamma) ', tau_z = ' num2str(1/gamma)])
    if length(idxcc) < ncc
      disp(['gamma_z was calculated with CC elements: ' num2str(setdiff(1:ncc,idxcc)) ' disconnected.'])
    end
    if length(idxvv) < nvv
      disp(['gamma_z was calculated with VV elements: ' num2str(setdiff(1:nvv,idxvv)) ' disconnected.'])
    end
  end
  dIs = (vecs(:,1));
  s='Vertical stability analyzed';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;

  % Make output structures
  dependent = {'cphi','r','z','rb','zb','rx','zx','rstrike','zstrike','drsep','qpsi',...
               'psipla','psimag','psibry','pprime','ffprim','L','A','V','I','W','In','Wn'};
  depunits = {'A','m','m','m','m','m','m','m','m','m','1',...
               'Wb','Wb','Wb','2*pi*N/Wb','2*pi*T','m','m^2','m^3','A','J','A','J'};       
  depdescr = {'current within grid cells',...
    'R of current centroid','Z of current centroid ',...
    'R of boundary points (first is x-point)',...
    'Z of boundary points (first is x-point)',...
    'R of lower and upper null',...
    'Z of lower and upper null',...
    'R of lower in/out, upper in/out strike points','Z of lower in/out, upper in/out strike points',...
    'outboard midplane distance between x-point flux surfaces, drsep',...
    'qpsi',...
    'plasma flux',...
    'psimag','psibry',...
    'pprime','ffprim',...
    'integral of 1/R within contours of normalized flux',...
    'area within contours of normalized flux',...
    'volumes within contours of normalized flux',...
    'current within contours of normalized flux',...
    'thermal energy within contours of normalized flux',...
    'current within normalized area',...
    'thermal energy within normalized volume'};
  if nq>0
    dependent(end+(1:2)) = {'rq','zq'};
    depunits(end+(1:2)) = {'m','m'};
    depdescr(end+1) = {[num2str(na) ' Rq values on each of ' num2str(nq) ' q-contours']};
    depdescr(end+1) = {[num2str(na) ' Zq values on each of ' num2str(nq) ' q-contours']};
  end
  if ngap>0
    dependent(end+1) = {'gap'};
    depunits(end+1) = {'m'};
    depdescr(end+1) = {'specified gaps'};
  end
  if niso>0
    dependent(end+(1:3)) = {'isopsi','isobr','isobz'};
    depunits(end+(1:3)) = {'Wb','T','T'};
    depdescr(end+1) = {'flux at iso point'};
    depdescr(end+1) = {'Br at iso point'};
    depdescr(end+1) = {'Bz at iso point'};
  end
  if ilimited
    depdescr{4} = 'R of boundary points (first is touch point)';
    depdescr{5} = 'Z of boundary points (first is touch point)';
  end
  if options.iconstraints == 1
    independent = {'is','betap','li','ip'};
    indepunits = {'A','1','1','A'};
    indepdescr = {'conductor currents','betap','li','plasma current'};
  elseif options.iconstraints == 2
    independent = {'is','w','li','ip'};
    indepunits = {'A','J','1','A'};    
    indepdescr = {'conductor currents','total thermal energy','li','plasma current'};
  elseif options.iconstraints == 3
    dependent{end+1} = 'betap'; depdescr{end+1}  = 'betap'; dependent{end+1} = 'li'; depdescr{end+1}  = 'li';
    depunits{end+1} = '1'; depunits{end+1} = '1';
    independent = {'is','W','I'};
    indepunits = {'A','J','A'};
    indepdescr = {'conductor currents','thermal energy profile points','plasma current profile points'};
  end
  com = 'response = struct(''mss'',mss,''xmats'',xmats';
  for j = 1:length(dependent)
    for k = 1:length(independent)
      varname = ['d' char(dependent{j}) 'd' char(independent{k})];
      com = [com ',''' varname ''',' varname];
    end
    if strmatch(char(dependent(j)),'qpsi','exact')
      varname = 'dqpsidbphi';
      com = [com ',''' varname ''',' varname];
    end
    if strmatch(char(dependent(j)),'rq','exact')
      varname = 'drqdbphi';
      com = [com ',''' varname ''',' varname];
    end
    if strmatch(char(dependent(j)),'zq','exact')
      varname = 'dzqdbphi';
      com = [com ',''' varname ''',' varname];
    end
  end
  com = [com ',''m_s'',m_s,''dIs'',dIs,''gamma'',gamma);'];
  eval(com)
  response.dpsizrdis = dpsizrdis;
  response.dpsizrdip = dpsizrdip;  

  response.descriptions.mss = 'vacuum mutual inductance matrix for conductors';
  response.descriptions.xmats = 'extra conductor coupling due to plasma response';
  response.units.mss = 'H';
  response.units.xmats = 'H';
  for j = 1:length(dependent)
    for k = 1:length(independent)
      varname = ['d' char(dependent{j}) 'd' char(independent{k})];
      eval(['response.descriptions.' varname '=''Response of: ' char(depdescr{j}) ' TO: ' char(indepdescr{k}) ''';']);
      eval(['response.units.' varname '=''' char(depunits{j}) '/' char(indepunits{k}) ''';']);
    end
    if strmatch(char(dependent(j)),'qpsi','exact')
      response.descriptions.dqpsidbphi = 'Response of: qpsi TO: toroidal field at eq.rzero';
      response.units.dqpsidbphi = '1/T';
    end
    if strmatch(char(dependent(j)),'rq','exact')
      response.descriptions.drqdbphi = ...
        ['Response of: ' num2str(na) ' Rq values on each of ' num2str(nq) ' q-contours TO: toroidal field at eq.rzero'];
      response.units.drqdbphi = 'm/T';
    end
    if strmatch(char(dependent(j)),'zq','exact')
      response.descriptions.dzqdbphi = ...
        ['Response of: ' num2str(na) ' Zq values on each of ' num2str(nq) ' q-contours TO: toroidal field at eq.rzero'];
      response.units.dzqdbphi = 'm/T';
    end
  end
  response.descriptions.m_s = 'Portone margin of stability: #1 eigenvalue of -inv(mss)*lstar';
  response.descriptions.dIs = 'current vector for unstable mode containing elements [idxcc idxvv idxtd]';
  response.descriptions.gamma = 'growth rate [rad/s]';
  
  eqx.psipla = psipla;
  eqx.rcur = rcur;
  eqx.zcur = zcur;
  eqx.ra = ra;
  eqx.za = za;
  eqx.ilimited = ilimited;
  eqx.r0 = r0;
  eqx.z0 = z0;
  if zx>za
    eqx.rx = [rx2 rx];
    eqx.zx = [zx2 zx];
  else
    eqx.rx = [rx rx2];
    eqx.zx = [zx zx2];
  end
  eqx.rstrike = rstrike;
  eqx.zstrike = zstrike;
  eqx.drsep = drsep;
  eqx.Rcnt = Rcnt;
  eqx.Zcnt = Zcnt;
  eqx.L = L;
  eqx.A = A;
  eqx.V = V;
  eqx.I = I;
  eqx.W = W;
  eqx.na = na;
  eqx.th0 = th0;
  eqx.betap = betap;
  eqx.li = li;
  if nq>0
    eqx.q = q;
    eqx.psiq = psiq;
    eqx.qprime = qprime;
    eqx.rq = rq;
    eqx.zq = zq;
    eqx.nq = nq;
  end
  if ngap>0
    eqx.gaps = gaps;
  end
  if niso>0
    eqx.isopsi = isopsi;
    eqx.isobz = isobz;
    eqx.isobr = isobr;
  end
  
  eqx.descriptions.psipla = 'plasma flux = jphi(:)''*psizr(:)/sum(jphi(:))';
  eqx.descriptions.rcur = 'R of current centroid';
  eqx.descriptions.zcur = 'Z of current centroid';
  eqx.descriptions.ra =  'R of magnetic axis';
  eqx.descriptions.za =  'Z of magnetic axis';
  eqx.descriptions.ilimited = '1 if plasma limited, 0 if diverted';
  eqx.descriptions.r0 =  r0descr;
  eqx.descriptions.z0 =  z0descr;
  eqx.descriptions.rx =  'R of any lower and upper null';
  eqx.descriptions.zx =  'Z of any lower and upper null';
  eqx.descriptions.rstrike =  'R of lower inner&outer and upper inner&outer strike points';
  eqx.descriptions.zstrike =  'Z of lower inner&outer and upper inner&outer strike points';
  eqx.descriptions.drsep =  'distance between x-point flux surfaces in outboard midplane';
  eqx.descriptions.Rcnt =  'R of contours of constant flux';
  eqx.descriptions.Zcnt =  'Z of contours of constant flux';
  eqx.descriptions.L =  'surface integrals of 1/R within flux contours';
  eqx.descriptions.A =  'areas within flux contours';
  eqx.descriptions.V =  'volumes within flux contours';
  eqx.descriptions.I =  'toroidal currents within flux contours';
  eqx.descriptions.W =  'thermal energy within flux contours';
  eqx.descriptions.na = 'number of angles, i.e. number of points on contours';
  eqx.descriptions.th0 = 'poloidal angle between axis and boundary defining point';
  eqx.descriptions.betap = 'betap calculated with Rcnt(:,end), Zcnt(:,end) instead of rbbbs, zbbbs';
  eqx.descriptions.li = 'li calculated with Rcnt(:,end), Zcnt(:,end) instead of rbbbs, zbbbs';
  if nq>0
    qstr = [];
    for j=1:nq
      s = num2str(q(j));
      for k=99:-1:1
        if abs(k*q(j)-round(k*q(j)))<1e-6
	  s = [num2str(round(k*q(j))) '/' num2str(k)];
	end
      end
      qstr = [qstr s ', '];
    end
    eqx.descriptions.q = [qstr ', the array of q values from the input options.q'];
    eqx.descriptions.psiq = 'flux values at q-surfaces';
    eqx.descriptions.qprime = 'dq/dpsi [1/(Wb/rad)]';
    eqx.descriptions.rq = ['R contour coordinates for each of the ' num2str(nq) ' q-surfaces'];
    eqx.descriptions.zq = ['Z contour coordinates for each of the ' num2str(nq) ' q-surfaces'];
    eqx.descriptions.nq = 'number of q-contours (length(options.q))';
  end
  if ngap>0
    eqx.descriptions.gaps = '(ngap,1:5) = gap, R,Z on limiter (or anywhere), R,Z on separatrix';
  end
  if niso>0
    eqx.descriptions.isopsi = 'flux in iso points';
    eqx.descriptions.isobz = 'Bz in iso points';
    eqx.descriptions.isobr = 'Br in iso points';
  end
  
  if nargout > 2 % Needed for gspertx
    misc.iverbose = iverbose;
    misc.W = W;
    misc.I = I;
    misc.iused = iused;
    misc.Minv = Minv;
    misc.dsdC = dsdC;
    misc.Wn_psizr = Wn_psizr;
    misc.In_psizr = In_psizr;
    misc.c0 = c0;
    misc.c1 = c1;
    misc.c2 = c2;
    misc.c3 = c3;
    misc.jp = jp;
    misc.jf = jf;
    misc.Cl = Cl;
    misc.dpsicds = dpsicds;
    misc.cphi = cphi;
    misc.iplasma = iplasma;
    misc.sumcphi = sumcphi;
    misc.ii0 = ii0;
    misc.iia = iia;
    misc.w0 = w0;
    misc.wa = wa;
    misc.psizr = psizr;
    misc.pprime = pprime;
    misc.ffprim = ffprim;
    misc.psimag = psimag;
    misc.psibry = psibry;
    misc.fpol = fpol;
    misc.pres = pres;
    misc.psibarzr = psibarzr;
    misc.jphi0 = jphi0;
    misc.mg = mg;
    misc.m = m;
    misc.djdp = djdp;
    misc.mu0 = mu0;
    misc.dr = dr;
    misc.dz = dz;
    misc.nr = nr;
    misc.nz = nz;
    misc.rgg = rgg;
    misc.zgg = zgg;
    misc.ib = ib;
    misc.neighbors = neighbors;
    misc.twopi = twopi;
    misc.rhob_psizr = rhob_psizr;
    misc.na = na;
    misc.didrhob = didrhob;
    misc.W_g = W_g;
    misc.I_g = I_g;
    misc.wbs = wbs;
    misc.L_psizr = L_psizr;
    misc.A_psizr = A_psizr;
    misc.V_psizr = V_psizr;
    misc.I_psizr = I_psizr;
    misc.W_psizr = W_psizr;
    misc.psigrid = psigrid;
    misc.Lprime = Lprime;
    misc.nq = nq;
    misc.qpsi = qpsi;
    misc.psiq = psiq;
    misc.rhoq_psizr = rhoq_psizr;
    misc.ths = ths;
    misc.ngap = ngap;
    if ngap>0
      misc.iigap = iigap;
      misc.wgap = wgap;
    end
    misc.niso = niso;
    if niso>0
      misc.iiiso = iiiso;
      misc.wiso = wiso;
    end
    misc.drsep = drsep;
    misc.iisep = iisep;
    misc.drsepdpsi = drsepdpsi;
    misc.d2rsepdpsi2 = d2rsepdpsi2;
    misc.rstrike = rstrike;
    misc.zstrike = zstrike;
    misc.drstrikedpsi = drstrikedpsi;
    misc.dzstrikedpsi = dzstrikedpsi;
    misc.iistrike = iistrike;
    misc.wstrike = wstrike;
    misc.iix = iix;
    misc.iix2 = iix2;
    misc.wx = wx;
    misc.wx2 = wx2;
    misc.wxr = wxr;
    misc.wx2r = wx2r;
    misc.wxz = wxz;
    misc.wx2z = wx2z;
    misc.wsep = wsep;
    misc.zx = zx;
    misc.za = za;
    misc.xshift_Bx = xshift_Bx;
    misc.x2shift_Bx = x2shift_Bx;
    misc.ilimited = ilimited;
    misc.wld = wld;
    misc.iilim = iilim;
    misc.psilimbis = psilimbis;
    misc.dVedgedrho = dVedgedrho;
    misc.DX = DX;
    misc.DY = DY;
    misc.cpieces = cpieces;
    misc.psizr_r = psizr_r;
    misc.psizr_z = psizr_z;
    misc.Cl = Cl;
    misc.Bp2edge = Bp2edge;
    misc.Bp2V = Bp2V;
    misc.betap = betap;
    misc.li = li;
    misc.V = V;
    misc.cpasma = cpasma;
    misc.options = options;
    if options.iconstraints == 1 % Perturbation that leaves betap, li, Ip unaltered
      misc.dcphidbetap    = dcphidbetap;    misc.dcphidli    = dcphidli;    misc.dcphidip    = dcphidip;
      misc.dpsipladbetap  = dpsipladbetap;  misc.dpsipladli  = dpsipladli;  misc.dpsipladip  = dpsipladip;
      misc.dpsimagdbetap  = dpsimagdbetap;  misc.dpsimagdli  = dpsimagdli;  misc.dpsimagdip  = dpsimagdip;
      misc.dpsibrydbetap  = dpsibrydbetap;  misc.dpsibrydli  = dpsibrydli;  misc.dpsibrydip  = dpsibrydip;
      misc.dLdbetap       = dLdbetap;       misc.dLdli       = dLdli;       misc.dLdip       = dLdip;
      misc.dAdbetap       = dAdbetap;       misc.dAdli       = dAdli;       misc.dAdip       = dAdip;
      misc.dVdbetap       = dVdbetap;       misc.dVdli       = dVdli;       misc.dVdip       = dVdip;
      misc.dIdbetap       = dIdbetap;       misc.dIdli       = dIdli;       misc.dIdip       = dIdip;
      misc.dWdbetap       = dWdbetap;       misc.dWdli       = dWdli;       misc.dWdip       = dWdip;
      misc.dIndbetap      = dIndbetap;      misc.dIndli      = dIndli;      misc.dIndip      = dIndip;
      misc.dWndbetap      = dWndbetap;      misc.dWndli      = dWndli;      misc.dWndip      = dWndip;
      misc.dpprimedbetap  = dpprimedbetap;  misc.dpprimedli  = dpprimedli;  misc.dpprimedip  = dpprimedip;
      misc.dffprimdbetap  = dffprimdbetap;  misc.dffprimdli  = dffprimdli;  misc.dffprimdip  = dffprimdip;
      misc.dqpsidbetap    = dqpsidbetap;    misc.dqpsidli    = dqpsidli;    misc.dqpsidip    = dqpsidip;
      misc.drqdbetap      = drqdbetap;      misc.drqdli      = drqdli;      misc.drqdip      = drqdip;
      misc.dzqdbetap      = dzqdbetap;      misc.dzqdli      = dzqdli;      misc.dzqdip      = dzqdip;
      misc.drbdbetap      = drbdbetap;      misc.drbdli      = drbdli;      misc.drbdip      = drbdip;
      misc.dzbdbetap      = dzbdbetap;      misc.dzbdli      = dzbdli;      misc.dzbdip      = dzbdip;
      misc.ddrsepdbetap   = ddrsepdbetap;   misc.ddrsepdli   = ddrsepdli;   misc.ddrsepdip   = ddrsepdip;
      misc.drstrikedbetap = drstrikedbetap; misc.drstrikedli = drstrikedli; misc.drstrikedip = drstrikedip;
      misc.dzstrikedbetap = dzstrikedbetap; misc.dzstrikedli = dzstrikedli; misc.dzstrikedip = dzstrikedip;
      misc.drxdbetap      = drxdbetap;      misc.drxdli      = drxdli;      misc.drxdip      = drxdip;
      misc.dzxdbetap      = dzxdbetap;      misc.dzxdli      = dzxdli;      misc.dzxdip      = dzxdip;
      misc.dgapdbetap     = dgapdbetap;     misc.dgapdli     = dgapdli;     misc.dgapdip     = dgapdip;
      misc.disopsidbetap  = disopsidbetap;  misc.disopsidli  = disopsidli;  misc.disopsidip  = disopsidip;
      misc.disobzdbetap   = disobzdbetap;   misc.disobzdli   = disobzdli;   misc.disobzdip   = disobzdip;
      misc.disobrdbetap   = disobrdbetap;   misc.disobrdli   = disobrdli;   misc.disobrdip   = disobrdip;
    elseif options.iconstraints == 2 % Perturbation that leaves Wth, li, Ip unaltered
      misc.dcphidw        = dcphidw;        misc.dcphidli    = dcphidli;    misc.dcphidip    = dcphidip;
      misc.dpsipladw      = dpsipladw;      misc.dpsipladli  = dpsipladli;  misc.dpsipladip  = dpsipladip;
      misc.dpsimagdw      = dpsimagdw;      misc.dpsimagdli  = dpsimagdli;  misc.dpsimagdip  = dpsimagdip;
      misc.dpsibrydw      = dpsibrydw;      misc.dpsibrydli  = dpsibrydli;  misc.dpsibrydip  = dpsibrydip;
      misc.dLdw           = dLdw;           misc.dLdli       = dLdli;       misc.dLdip       = dLdip;
      misc.dAdw           = dAdw;           misc.dAdli       = dAdli;       misc.dAdip       = dAdip;
      misc.dVdw           = dVdw;           misc.dVdli       = dVdli;       misc.dVdip       = dVdip;
      misc.dIdw           = dIdw;           misc.dIdli       = dIdli;       misc.dIdip       = dIdip;
      misc.dWdw           = dWdw;           misc.dWdli       = dWdli;       misc.dWdip       = dWdip;
      misc.dIndw          = dIndw;          misc.dIndli      = dIndli;      misc.dIndip      = dIndip;
      misc.dWndw          = dWndw;          misc.dWndli      = dWndli;      misc.dWndip      = dWndip;
      misc.dpprimedw      = dpprimedw;      misc.dpprimedli  = dpprimedli;  misc.dpprimedip  = dpprimedip;
      misc.dffprimdw      = dffprimdw;      misc.dffprimdli  = dffprimdli;  misc.dffprimdip  = dffprimdip;
      misc.dqpsidw        = dqpsidw;        misc.dqpsidli    = dqpsidli;    misc.dqpsidip    = dqpsidip;
      misc.drqdw          = drqdw;          misc.drqdli      = drqdli;      misc.drqdip      = drqdip;
      misc.dzqdw          = dzqdw;          misc.dzqdli      = dzqdli;      misc.dzqdip      = dzqdip;
      misc.drbdw          = drbdw;          misc.drbdli      = drbdli;      misc.drbdip      = drbdip;
      misc.dzbdw          = dzbdw;          misc.dzbdli      = dzbdli;      misc.dzbdip      = dzbdip;
      misc.ddrsepdw       = ddrsepdw;       misc.ddrsepdli   = ddrsepdli;   misc.ddrsepdip   = ddrsepdip;
      misc.drstrikedw     = drstrikedw;     misc.drstrikedli = drstrikedli; misc.drstrikedip = drstrikedip;
      misc.dzstrikedw     = dzstrikedw;     misc.dzstrikedli = dzstrikedli; misc.dzstrikedip = dzstrikedip;
      misc.drxdw          = drxdw;          misc.drxdli      = drxdli;      misc.drxdip      = drxdip;
      misc.dzxdw          = dzxdw;          misc.dzxdli      = dzxdli;      misc.dzxdip      = dzxdip;
      misc.dgapdw         = dgapdw;         misc.dgapdli     = dgapdli;     misc.dgapdip     = dgapdip;
      misc.disopsidw      = disopsidw;      misc.disopsidli  = disopsidli;  misc.disopsidip  = disopsidip;
      misc.disobzdw       = disobzdw;       misc.disobzdli   = disobzdli;   misc.disobzdip   = disobzdip;
      misc.disobrdw       = disobrdw;       misc.disobrdli   = disobrdli;   misc.disobrdip   = disobrdip;
    end
  end
  s='Output structure made';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;

  % Plotting section
  if isfield(options,'gspertfigno')
    gspertfigno = options.gspertfigno;
  else
    gspertfigno = 111;
  end
  if length(idoplots)==1, idoplots=idoplots+zeros(1,nss+1+3*(options.iconstraints~=3)); end % plot w,li,ip,is responses
  framecount = 0;
  if ~isfield(options,'iframe4movie')
    options.iframe4movie = 0;
  end
  if ~isfield(options,'what2plot')
    options.what2plot = 1;
  end
  if iverbose >= 2 & max(abs(idoplots))>0
    disp('Plotting selected plasma responses...');
    if options.iframe4movie
      disp('Also producing pictures that can be used to make a movie...');
    end
  end
  if options.iconstraints == 3
    kplotloop = [-2*nr-3:-nr-4 -nr-3:-4 0:nss+length(vals)]; idoplots([1 nr+1]) = 0;
  else
    kplotloop = -3:nss+length(vals);
  end
  idoplots(kplotloop(end)-kplotloop(1)+2) = 0; % This guarantees that idoplot is long enough
  for k = kplotloop
    if ~exist('dpsizr_pla','var')
      dpsizr_pla = psizr;
    end
    if idoplots(k-kplotloop(1)+1)
      effect = ''; dpsizr_app = 0*psizr;;
      if k < -3-nr
        kk = k-kplotloop(1)+1;
	s =  num2str(kk); ss=[]; for j=1:length(s), ss=[ss '_' s(j)]; end
	unit = [' per Joule of W_t_h(V' ss '/V_t_o_t)']; effect = 'Wth profile point';
	dWn = dWndW(:,kk); dIn = dIndW(:,kk); dcphi = dcphidW(:,kk);
      elseif k<-3
        kk = k-kplotloop(1)+1-nr;
	s =  num2str(kk); ss=[]; for j=1:length(s), ss=[ss '_' s(j)]; end
	unit = [' per Ampere of I(A' ss '/A_t_o_t)']; effect = 'I profile point';
	dWn = dWndI(:,kk); dIn = dIndI(:,kk); dcphi = dcphidI(:,kk);
      elseif k==-3
        if options.iconstraints==1
	  unit = ' per unit of \beta_p'; effect = '\beta_p';
	  dWn = dWndbetap; dIn = dIndbetap; dcphi = dcphidbetap(:);
	else
	  unit = ' per Joule of W_t_h'; effect = 'Wth';
	  dWn = dWndw; dIn = dIndw; dcphi = dcphidw(:);
	end
      elseif k==-2
        unit = ' per unit of li'; effect = 'li';
	dWn = dWndli; dIn = dIndli; dcphi = dcphidli(:);
      elseif k==-1
        unit = ' per Amp of I_p'; effect = 'I_p';
	dWn = dWndip; dIn = dIndip; dcphi = dcphidip(:);
      elseif k==0
        unit = ''; effect = ['time, \gamma_z=' num2str(gamma)];
	dis = zeros(ncc+nvv+ntd,1); dis(idxss) = dIs;
	dWn = dWndis*dis; dIn = dIndis*dis; dcphi = dcphidis*dis;
	dpsizr_app = reshape([mpc mpv mpt]*dis,nz,nr);
      elseif k>0 & k<=nee
        if isfield(tok_data_struct,'ecnames')
	  effect = tok_data_struct.ecnames(k,:);
	end
	dpsizr_app = reshape(mpc(:,k),nz,nr);
	unit = [' per Amp in ' deblank(effect)];
	dWn = dWndis(:,k); dIn = dIndis(:,k); dcphi = dcphidis(:,k);
      elseif k>nee & k<=ncc
        if isfield(tok_data_struct,'fcnames')
	  effect = tok_data_struct.fcnames(k-nee,:);
	end
        if isfield(tok_data_struct,'ccnames')
	  effect = tok_data_struct.ccnames(k,:);
	end
	dpsizr_app = reshape(mpc(:,k),nz,nr);
	unit = [' per Amp in ' deblank(effect)];
	dWn = dWndis(:,k); dIn = dIndis(:,k); dcphi = dcphidis(:,k);
      elseif k>ncc & k<=ncc+nvv
        if isfield(tok_data_struct,'vvnames')
	  effect = tok_data_struct.vvnames(k-ncc,:);
	else
	  effect = ['VV' num2str(k-ncc)];
	end
	dpsizr_app = reshape(mpv(:,k-ncc),nz,nr);
	unit = [' per Amp in ' deblank(effect)];
	dWn = dWndis(:,k); dIn = dIndis(:,k); dcphi = dcphidis(:,k);
      elseif k>ncc+nvv & k<=ncc+nvv+ntd
        if isfield(tok_data_struct,'tdnames')
	  effect = tok_data_struct.tdnames(k-ncc-nvv,:);
	else
	  effect = ['TD' num2str(k-ncc)];
	end
	dpsizr_app = reshape(mpt(:,k-ncc-nvv),nz,nr);
	unit = [' per Amp in ' deblank(effect)];
	dWn = dWndis(:,k); dIn = dIndis(:,k); dcphi = dcphidis(:,k);
      else % Show eigen modes
        unit = ''; effect = ['eigen mode #' num2str(k-ncc-nvv) ', \gamma=' num2str(vals(k-ncc-nvv))];
	dis = zeros(ncc+nvv,1); dis(idxss) = vecs(:,k-ncc-nvv);
	dWn = dWndis*dis; dIn = dIndis*dis; dcphi = dcphidis*dis;
	dpsizr_app = reshape([mpc mpv]*dis,nz,nr);
      end
      figure(gspertfigno),clf
      h=subplot(2,2,2); set(h,'pos',[0.60 0.58 0.37 0.34]);
      plot(V/V(end),dWn)
      % Show any recommended variation of thermal energy profile
      dy = NaN*V;
      if k==-3
       if isfield(options,'dWndbetap')
         dy = constraints.dWndbetap;
       end
       if isfield(options,'dWndw') & options.iconstraints~=1
         dy = constraints.dWndw;
       end
      end
      if k==-2 & isfield(options,'dWndli')
       dy = constraints.dWndli;
      end
      if k==-1 & isfield(options,'dWndip')
       dy = constraints.dWndip;
      end
      hold on; plot(V/V(end),dy,'r--')
      if k < -3-nr
        a = axis;
	plot(V(kk)/V(end)+[0 0],a(3:4),'r--')
	plot([0 1],[1 1],'r--')
      end
      h = title(['\delta[ \int_0^ ^\psi 3/2pdV ]' unit]); set(h,'fonts',12);
      h = xlabel('V(\psi) / V_t_o_t');
      h = ylabel('[Joule]');
      h=subplot(2,2,4); set(h,'pos',[0.60 0.09 0.37 0.34]);
      plot(A/A(end),dIn)
      % Show any recommended variation of current profile
      dy = NaN*A;
      if k==-3
       if isfield(options,'dIndbetap')
         dy = options.dIndbetap;
       end
       if isfield(options,'dIndw') & options.iconstraints==1
         dy = options.dIndw;
       end
      end
      if k==-2 & isfield(options,'dIndli')
       dy = options.dIndli;
      end
      if k==-1 & isfield(options,'dIndip')
       dy = options.dIndip;
      end
      hold on; plot(A/A(end),dy,'r--')
      if k < -3 & k>=-3-nr
        a = axis;
	plot(A(kk)/A(end)+[0 0],a(3:4),'r--')
	plot([0 1],[1 1],'r--')
      end
      h = title(['\delta[ \int_0^ ^\psi j_\phidA ]' unit]); set(h,'fonts',12);
      h = xlabel('A(\psi) / A_t_o_t');
      h = ylabel('[Ampere]');
      h=subplot(2,2,1); set(h,'pos',[0.1 0.08 0.4 0.84]);
      plot_tok_geo(tok_data_struct), hold on, plot(rlimdata,zlimdata,'b');
      for j =1:ntd % Plot projection of td coils in magenta
        plot(sqrt(tok_data_struct.tddata{j}(:,1).^2+tok_data_struct.tddata{j}(:,2).^2),tok_data_struct.tddata{j}(:,3),'m')
      end
      for j = 1:ngg
	iru = ceil(j/nz);
	for l=1:nused
	  irp = ceil(iused(l)/nz);
	  idz = 1+abs(j-iused(l)+(irp-iru)*nz);
	  coupling(l) = mpp(idz+(iru-1)*nz,irp);
	end
	dpsizr_pla(j) = dr*dz*coupling*dcphi(iused);
      end
      dpsizr = dpsizr_pla+dpsizr_app;
      dpsibry = dpsizr(ii0)*w0'; dpsimag = dpsizr(iia)*wa';
      if options.what2plot == 1 % Plot change of psizr
	dpsimin = min(dpsizr(iplasma)); dpsimax = max(dpsizr(iplasma));
	maxabs = max(abs([dpsimin,dpsimax]));
	[c,h]=contour([Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)],...
          interp2(rg,zg,dpsizr,[Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)]),linspace(dpsimin,dpsimax,99));
	if isempty(strfind(version,'R13'))
	  set(h,'fill','on');
	end
	h = title([upper(tokamak) ' \psi response to ' deblank(effect)]);
	if k > ncc+nvv
	  h = title([upper(tokamak) ' \psi ' effect]);
	end
	set(h,'fonts',15);
      elseif options.what2plot == 2 % Plot change of normalized psizr
	dpsibarzr = (dpsizr-psibarzr*dpsibry-(1-psibarzr)*dpsimag)/(psibry-psimag);
	dpsimin = min(dpsibarzr(iplasma)); dpsimax = max(dpsibarzr(iplasma));
	maxabs = max(abs([dpsimin,dpsimax]));
	[c,h]=contour([Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)],...
          interp2(rg,zg,dpsibarzr,[Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)]),linspace(dpsimin,dpsimax,99));
	if isempty(strfind(version,'R13'))
	  set(h,'fill','on');
	end
	h = title([upper(tokamak) ' normalized \psi response to ' deblank(effect)]);
	if k > ncc+nvv
	  h = title([upper(tokamak) ' normalized \psi ' effect]);
	end
	set(h,'fonts',15);
      elseif options.what2plot == 3 % Plot change of dpsizr_pla
	dpsimin = min(dpsizr_pla(iplasma)); dpsimax = max(dpsizr_pla(iplasma));
	maxabs = max(abs([dpsimin,dpsimax]));
	[c,h]=contour([Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)],...
          interp2(rg,zg,dpsizr_pla,[Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)]),linspace(dpsimin,dpsimax,99));
	if isempty(strfind(version,'R13'))
	  set(h,'fill','on');
	end
	h = title([upper(tokamak) ' \psi^p^l^a response to ' deblank(effect)]);
	if k > ncc+nvv
	  h = title([upper(tokamak) ' \psi^p^l^a ' effect]);
	end
	set(h,'fonts',15);
      elseif options.what2plot == 4 % Plot change of jphi
	djphi = reshape(dcphi/dr/dz,nz,nr);
	djphimin = min(djphi(iplasma)); djphimax = max(djphi(iplasma));
	maxabs = max(abs([djphimin,djphimax]));
	[c,h]=contour([Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)],...
          interp2(rg,zg,djphi,[Rcnt; Rcnt(1,:)],[Zcnt; Zcnt(1,:)]),linspace(djphimin,djphimax,99));
	if isempty(strfind(version,'R13'))
	  set(h,'fill','on');
	end
	h = title([upper(tokamak) ' j_\phi response to ' deblank(effect)]);
	if k > ncc+nvv
	  h = title([upper(tokamak) ' j_\phi ' effect]);
	end
	set(h,'fonts',15);
      end
      caxis([-maxabs,maxabs]);
      plot(rdivleg,zdivleg,'g')
      colorbar
      if k==0
        h2 = [];
        for j = 1:size(ecdata,2)
	  if ismember(ecdata(5,j),idxcc)
            h2x = plot_boxx(ecdata(2,j),ecdata(1,j),ecdata(4,j),ecdata(3,j),'y',0,0);
            h2 = [h2; h2x(:)];
	  end
        end
        for j = 1:ncc-nee
	  if ismember(j+nee,idxcc)
            h2x = plot_boxx(fcdata(2,j),fcdata(1,j),fcdata(4,j),fcdata(3,j),'y',fcdata(5,j),fcdata(6,j));
            h2 = [h2; h2x(:)];
	  end
        end
        for j = idxvv
          h2x = plot_boxx(vvdata(2,j),vvdata(1,j),vvdata(4,j),vvdata(3,j),'y',vvdata(5,j),vvdata(6,j));
          h2 = [h2; h2x(:)];
        end
	for j = idxtd
          h2x = plot(sqrt(tok_data_struct.tddata{j}(:,1).^2+tok_data_struct.tddata{j}(:,2).^2),...
	    tok_data_struct.tddata{j}(:,3));
          h2 = [h2; h2x(:)];
	end
      elseif k>0 & k<=nee
        h2 = [];
        for j = find(ecdata(5,:)==k)
          h2x = plot_boxx(ecdata(2,j),ecdata(1,j),ecdata(4,j),ecdata(3,j),'y',0,0);
	  h2 = [h2; h2x(:)];
	end
      elseif k>nee & k<=ncc
        h2 = plot_boxx(fcdata(2,k-nee),fcdata(1,k-nee),fcdata(4,k-nee),fcdata(3,k-nee),'y', ...
	  fcdata(5,k-nee),fcdata(6,k-nee));
      elseif k>ncc & k<=ncc+nvv
        h2 = plot_boxx(vvdata(2,k-ncc),vvdata(1,k-ncc),vvdata(4,k-ncc),vvdata(3,k-ncc),'y', ...
	  vvdata(5,k-ncc),vvdata(6,k-ncc));
      elseif k>ncc+nvv & k<=ncc+nvv+ntd
        h2 = plot(sqrt(tok_data_struct.tddata{k-ncc-nvv}(:,1).^2+tok_data_struct.tddata{k-ncc-nvv}(:,2).^2),...
	  tok_data_struct.tddata{k-ncc-nvv}(:,3),'y');
      end
      if options.iframe4movie
	% Make movie frames
	framecount = framecount+1;
	f = getframe(gspertfigno); g = frame2im(f);
	s = num2str(framecount); while length(s)<8, s = ['0' s]; end
	imwrite(g,['gspert_response_in_' tokamak '_pic' s '.jpeg'],'jpeg');
      end
      
      for j = 1:ngap
        plot([gaps(j,2) gaps(j,4)],[gaps(j,3) gaps(j,5)]);
	gapangle = angle(gaps(j,2)-gaps(j,4)+sqrt(-1)*(gaps(j,3)-gaps(j,5)));
	plot(gaps(j,4)+[0 dr]*cos(gapangle-pi/6),gaps(j,5)+[0 dr]*sin(gapangle-pi/6))
 	plot(gaps(j,4)+[0 dr]*cos(gapangle+pi/6),gaps(j,5)+[0 dr]*sin(gapangle+pi/6))
      end

      if idoplots(k-kplotloop(1)+1)>0
	for l=0:.4:idoplots(k-kplotloop(1)+1)
	  % set(h,'color','r');
	  if k >=0 & k <= ncc+nvv+ntd, set(h2,'color','y'); end
	  pause(0.2)
	  % set(h,'color','w');
	  if k >=0 & k <= ncc+nvv+ntd, set(h2,'color','w'); end
	  pause(0.2)
	end
      else
        wait
      end
      s=['Made plot of ' effect 'response'];
      mexec(end+1,1:length(s)) = s;
      texec(end+1) = (now-t0)*secperday;
    end % End of idoplots
  end
  
  s='All done';
  mexec(end+1,1:length(s)) = s;
  texec(end+1) = (now-t0)*secperday;
  misc.execution_began = datestr(t0);
  misc.mexec = mexec;
  misc.texec = texec;
  if iverbose >= 2, disp('All done.'); end
  
  if ~isfield(options,'execAnalysis'), options.execAnalysis = 0; end
  if options.execAnalysis
    figure;
    plot(texec)
    for j=1:length(texec),text(j,texec(j),mexec(j,:));end
    ylabel('Execution time [sec]')
    title(['Execution analysis, ' num2str(nz) 'x' num2str(nr) ' grid'])
  end
