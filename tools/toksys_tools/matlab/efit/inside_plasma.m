  function inside= inside_plasma(psizr, rgefit,zgefit, rbbbs,zbbbs,nbbbs,...
                                 psimag,psibnd, iplot,dofast)
%
% inside_plasma sets matrix "inside" to 0's & 1's for outside & inside plasma
% 
% SYNTAX:
%   inside= inside_plasma(psizr, rgefit,zgefit, rbbbs,zbbbs,...
%                         psimag,psibnd, iplot,dofast);
%   inside= inside_plasma(psirz, rgefit,zgefit, rbbbs,zbbbs); % minimum input
%
%  PURPOSE: set matrix "inside" with 0's or 1's depending if inside or outside
%           plasma. Uses same input as typically generated by read_gfile
%
%  INPUTS: <default> [optional]
%
%          psizr=   Flux on plasma grid in (nz,nr) array format (Wb)
%          rgefit=  Radius vector of plasma grid (m)
%          zgefit=  Z vector of plasma grid (m)
%          rbbbs=   Radius vector of closed polygon plasma boundary (m)
%          zbbbs=   Z vector of closed polygon plasma boundary (m)
%          nbbbs=   number of elements to use in rbbbs,zbbbs
%         [psimag]= Flux on axis (Wb) <max(max(psizr))>
%         [psibnd]= Flux on boundary (Wb)  <average of psi on boundary>
%         [iplot]=  1; plot results <0>, 2= outside plasma only
%         [dofast]= 1; % increases algorithm speed at risk of including some
%                   private flux in solution. Only extreme shapes like
%                   crescents and beans are expected to need dofast=0.
%                   Default is dofast=0 since speed is still very fast. <0>
%
%  OUTPUTS:
%
%          inside=  Matrix of 1's & 0's for inside or outside plasma  (nz,nr)
%
%  RESTRICTIONS:
%          rb,zb adjacent elements cant be identical.
%          Not tested for coarse plasma boundary polygon mesh.
%          
%  METHOD: 
%          uses limits to do most screening and finally FE triangular formula 

%  WRITTEN BY:  Jim Leuer ON 6-3-03	
%
%  MODIFICATION HISTORY:
%
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input Checks:

  if nargin==9
    dofast= 0;
  elseif nargin==8
    iplot=1;
    dofast= 0;
  elseif nargin==7
    psibnd= mean(interp2(rgefit,zgefit,psizr,rbbbs,zbbbs));
    iplot=0;
    dofast= 0
  elseif nargin==6
    psimag= max(max(psizr));
    psibnd= mean(interp2(rgefit,zgefit,psizr,rbbbs,zbbbs));
    iplot=0;
    dofast= 0;
  elseif nargin==5
    nbbb= length(rbbb);
  elseif nargin<=4
    disp('%ERROR inside_plasma: Needs atleast 4 arguments to work')
    return
  end
      
% ========================================================================
% INITIAL SETUP PARAMTERS (boundary, grid, plasma)

  inside= zeros(size(psizr)); %  0's mean plasma 1's means no plasma

% ---------------------------------------------------------------------
% boundary polygon manipuliation to get in CCW and assending angle order

  rbb= rbbbs(1:nbbbs);  zbb= zbbbs(1:nbbbs);
  if(size(rbb,1)==1), rbb=rbb'; end; % make sure its a column vector
  if(size(zbb,1)==1), zbb=zbb'; end; % make sure its a column vector
  rb0= mean(rbb);       zb0= mean(zbb);
  if rbb(1)==rbb(end) & zbb(1)==zbb(end)  % remove duplicate last point
    rbb= rbb(1:end-1);  zbb= zbb(1:end-1);
  end
  
  drb= rbb-rb0;
  dzb= zbb-zb0;
% assending angular order from -pi makes this Counter Clockwise CCW
  angb= atan2(dzb,drb);
  [angb,id]= sort(angb);
% make sure -pi to +pi is covered in assending order
  rbb= rbb([id(end); id; id(1)]); % add points at front and back for 2pi
  zbb= zbb([id(end); id; id(1)]); % add points at front and back for 2pi
  angb= angb([id(end); id; id(1)]); % add points at front and back for 2pi
  angb(1)= angb(1)-2*pi;    % make 1 and end correct 
  angb(end)= angb(end)+2*pi; %
  drb= drb([id(end); id; id(1)]);
  dzb= dzb([id(end); id; id(1)]);
  radb= sqrt(drb.^2+dzb.^2);
  radbmn= min(radb);
  
  drbmx= max(drb);
  drbmn= min(drb);
  dzbmx= max(dzb);
  dzbmn= min(dzb);

% plot(drb,dzb,'.b'), hold on, plot(drb([1,end]),dzb([1,end]),'rx'), grid on
    
% Geometrical setup for particular grid

  r2= ones(length(zgefit),1)*rgefit'; % same size as psizr
  z2= zgefit*ones(1,length(rgefit));
  dr2= r2-rb0;
  dz2= z2-zb0;

% plasma boundary psi limits clipped at grid limits

  psibmx= max(max(psizr));
  psibmn= min(min(psizr));

  psibmx= min([psibmx, max(psibnd,psimag)]); % insure clip at grid values
  psibmn= max([psibmn, min(psibnd,psimag)]); % insure clip at grid values
  
% ======================================
% Main Selection Part
% ======================================

% ======================================
% 1st sort on center to boundary flux
%  figure(3)
%  clf
%  plot(rbbbs,zbbbs,'k')
%  hold on
%  axis equal
      
  id1= find(psizr >= psibmn & psizr <= psibmx); % find points within min:max psi
  inside(id1)= 1;

%  idplt= find(inside);
%  plot(r2(idplt),z2(idplt),'r.')


% ======================================
% 2nd sort on min/max Delta dimensions

  ii= ones(size(id1));  
  id2= find( dr2(id1)<drbmn | dr2(id1)>drbmx | dz2(id1)<dzbmn | dz2(id1)>dzbmx);
  ii(id2)= 0;

  id2no= id1(find(~ii)); % find 0's which are outside plasma
  inside(id2no)= 0;      % set points outside plasma to zero
  id22= id1(find(ii));   % this is remaining set that have ones
  
%  idplt= find(inside);
%  plot(r2(idplt),z2(idplt),'b*')

% ===========================================================================
% For most plasma we really dont have to do the below detailed calculations
 if ~dofast   

% ======================================
% 3rd eliminate points close to center based on smallest radius

  rad= sqrt(dr2(id22).^2 + dz2(id22).^2);

  ii= ones(size(id22));
  id3= find(rad <= radbmn);
  ii(id3)= 0; % this are GOOD point but dont have to do angle; inside already 1
  id23= find(ii);
  id33= id22(id23);  
%  plot(r2(id33),z2(id33),'go') % now we must work on these points with angles

% reduce set to work on:

  rad= rad(id23); % reduced set to work on
  ang= atan2(dz2(id33),dr2(id33)); 

% ======================================
% 4th elimination based on angle
     
%  pause

% loop over boundary lines
  for ibm=1:length(drb)-1 %
% ibm=5; ibm= ibm+1

    ibp= ibm+1; % boundary line end point id
%    plot(rbb([ibm,ibp]),zbb([ibm,ibp]),'co')
%    plot(rbb([ibm,ibp]),zbb([ibm,ibp]),'c')
%    plot([rbb(ibm),rb0],[zbb(ibm),zb0],'c')
%    plot([rbb(ibp),rb0],[zbb(ibp),zb0],'c')
%    plot(rb0,zb0,'ro')
        
    id= find(ang>= angb(ibm) & ang<= angb(ibp)); % all points to process
%    plot(r2(id33(id)),z2(id33(id)),'b.')

    if ~isempty(id)
       radbm= min(radb(ibm:ibp));
       id3= find(rad(id) > radbm); % Eliminates most points inside radius

%      Final detailed calculation based on local proximity to boundary
%      new method uses FE rotation dircetion of triangle see segerlind, pg29
%      assumes boundary is traversed in CCW direction
%      i=>j is boundary line, k is plasma point (use delta coordinates)
       if ~isempty(id3) % work on all points which outside minimum bound rad
           xi= drb(ibm);
	   yi= dzb(ibm);
	   xj= drb(ibp);
	   yj= dzb(ibp);

           for ii=1:length(id3) % loop over remaining points to see if inside
%            ii=0, ii=ii+1;
             id4= id33(id(id3(ii))); % pointer to main arrays
%             plot(r2(id4),z2(id4),'ro')
             xk= dr2(id4);
	     yk= dz2(id4);             
	     ccw= (xj-xi)*(yk-yj)-(xk-xj)*(yj-yi); % inside= + ccw around triang

%             plot([xi,xj,xk,xi]+rb0,[yi,yj,yk,yi]+zb0,'r')     
%             arrow_head([xi;xj]+rb0,[yi;yj]+zb0,.1,'r');
%             arrow_head([xj;xk]+rb0,[yj;yk]+zb0,.1,'r');

             if ccw < 0
               inside(id4)=0; % this is where final points eliminated
%               plot([rb0,xx+rb0],[zb0,yy+zb0],'r')
             end
        
%            pause(3)
%            disp('paused')
%            pause
           end % for ii    

       end % ~isempty(id3)

%      need to reduce rad and ang by points processed        
       jj= ones(size(rad)); % all indexes in rad & ang;
       jj(id)= 0;             % eliminate all point processed
       id23= find(jj);
       id33= id33(id23); % reduce main pointer count
       rad= rad(id23);   % reduced set to work on
       ang= ang(id23); 
%       pause
                
     end % ~isempty(id)

  end    % for ibm
 end     % dofast
 
% ======================================
% plot results

  if iplot
%    plot(rgefit([1;end;end;1;1]),zgefit([1;1;end;end;1]),'r')
    plot(rbbbs(1:nbbbs),zbbbs(1:nbbbs),'k')
    hold on
    axis equal
% jal ERROR WORK AROUND FOR MAC/X11/ssh/THOR/MATLAB13 4/6/2005
    if size(r2,1)*size(z2,2) >= 2145
     inside1= inside(1:2:size(inside,1),1:2:size(inside,2));
     r2= r2(1:2:size(r2,1),1:2:size(r2,2));
     z2= z2(1:2:size(z2,1),1:2:size(z2,2));
    else
     inside1= inside;
    end
     idd= find(~inside1);
     plot(r2(idd),z2(idd),'b.')

    if iplot==1
      idd= find(inside1);
      plot(r2(idd),z2(idd),'r.')
    end
  end

% ======================================

  return


% test: see also inside_plasma_old.m for different different algorithm
   
%  filename= '/users/walker/NSTX/g107167.00223'; % looks like BAD current data
%  read_gfile_nstx
%  nargin=8;    
%  inside= inside_plasma(psizr,rgefit,zgefit,rbbbs,zbbbs,nbbbs,psimag,psibnd,1,0);  
%  clear
  
%  filename= '/u/leuer/efit/diiid/g110214.01740';
%  read_gfile
%  inside= inside_plasma(psizr,rgefit,zgefit,rbbbs,zbbbs,nbbbs,psimag,psibnd,1,0);  


        
