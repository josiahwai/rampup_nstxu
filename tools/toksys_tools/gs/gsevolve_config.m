%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  USAGE:   gsevolve_config
%
%  PURPOSE: Template for configuration of gsevolve
%           All configuration options are included to facilitate
%           modifications needed for any configuration
%
%  INPUTS:  none
%
%  OUTPUTS: config, the variable used to configure gsevolve
	
%  VERSION @(#)gsevolve_config.m	1.2 02/23/15
%
%  WRITTEN BY:  Anders Welander  ON	6/28/14
%
%  MODIFICATION HISTORY:				
%	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% PLEASE RENAME AND SAVE A LOCAL COPY OF THIS TEMPLATE

% The script walks through the configuration process in 6 steps:
% 1. Choose tokamak
% 2. Choose evolution option
% 3. Configure inputs
% 4. Configure outputs
% 5. Run-time plot options
% 6. Miscellaneous settings
% 7. About reconfigurations

% TIP
% If the output from gsevolve_module is saved to a time-series object,
% the script gsevolve_module_post_analysis.m can be used to create
% suitably named variables with time traces of the outputs


% The gsevolve code must be configured with information about the tokamak
% and several simulation options. In the following this data will be
% written to a structure called 'config'
% This script configures a simulation of EAST as the example



% STEP 1: LOAD TOKAMAK 

% This is done by loading a TokSys tok_data_struct:

load /m/GAtools/tokamaks/east/make/east_obj_2014_3333.mat

% Begin by assigning tok_data_struct to config:

config = tok_data_struct;

% Note that the grid in the simulation need NOT match 
% a grid in an equilibrium that is used for initialization
% Grid sizes of 33x33 or 33x65 or 65x65 are recommended for simulations
% Generally smaller grids < 33 give modest speed gain but large loss of accuracy
% while grids > 65 lead to much longer execution time but almost no change in
% results compared to 65x65

% The grid can be changed if desired using function 'regrid', example:
% config = regrid(33,65,config);



% STEP 2: HOW TO EVOLVE

% Select one of the following evolve_option:
% 1. "Scalar Ip evolution"
% 2. "Profile evolution"
% 9. "External evolution"

config.evolve_option = 9;

if config.evolve_option == 1
  
  % If "Scalar Ip evolution" is chosen, 
  % the plasma resistance can be set with:
  config.plares = 1e-7;
  % Alternatively, resistance can vary during the simulation:
  config.plares.times = [0 1 2];
  config.plares.values = [1 2 1]*1e-7;
  % The first value is used for times before the first time
  % and the last value is held for times beyond the last time
  
  % The first input u.vcd(1) is voltage from current drive
  % as if a power supply had been attached to the plasma
  % The second input is d(li)/dt
  % The third input is d(betap)/dt if config.constraints = 1
  % or d(Wth)/dt if config.constraints = 2
  config.constraints = 1;

elseif config.evolve_option == 2

  % For "profile evolution", the plasma resistivity versus 
  % rhot (sqrt(normalizded toroidal flux)) is specified, example:
  config.eta_vs_rhot = linspace(1e-8,4e-8);
  % This vector can be any length.
   
  config.constraints = 0;

elseif config.evolve_option == 9
  
  % "External evolution" is like evolve_option 1 
  % but Ip is also evolved externally
  
  % The first input u.vcd(1) is d(Ip)/dt
  % The second input is d(li)/dt
  % The third input is d(betap)/dt if config.constraints = 1
  % or d(Wth)/dt if config.constraints = 2
  config.constraints = 1;

end



% STEP 3a: INPUTS FOR COILS

% The coils are connected in circuits with power supplies
% Power supply voltages are sent into gsevolve with u.vps
% In the gsevolve module this signal is labeled 'PS'
% This vector can be any length when gsevolve is used by itself
% but when used in the gsevolve module, the number of points 
% in this vector must be specified with field 'nps'.
% Three options exist for setting up the circuits:
% 1. config.cccirc - each index is a coil, each value a circuit number
% 2. config.buscode - each index is a coil, 0 = free, 1 = connected to bus
% 3. config.netlist - a data object generated by netlist code

config.cccirc =  [1 2 3 4 5 6 7 8 7 8 9 10 11 12 13 -13];

% If the field 'netlist' is supplied then it will be used for circuits
% and the following description of resistances and inductances won't matter.

% The fields 'resc' and 'resv' contain resistances in coils and vessel elements.
% Here the PF coils for EAST are given a much lower resistance since they
% are in fact super conducting  
config.resc(1:14) = config.resc(1:14)/1e6;

% Extra resistances in coils or vessel elements can be described in 'Rextra'
% This is a matrix which by default is zeros(nc+nv)
% In this example there are gap resistors between the passive plate sections
% in EAST that must be added
for i = 81:90 % PP extra resistance
  config.Rextra(config.nc+i,config.nc+i) = 15.8e-3;
end

% Similarly extra inductance can be added with 'Lextra'

% The number of power supplies is in this case:
config.nps = max(abs(config.cccirc));
% This field is not necessary for gsevolve
% But is for the simulink module gsevolve_module



% STEP 3b: INPUTS FOR CURRENT DRIVE AND HEATING

% Current drive is sent into gsevolve with u.vcd
% In the gsevolve module this input is labeled 'CD'

if config.evolve_option == 1
  
  % There are three signals in this line:
  % 1. Driven current * plasma resistance (plares) [V]
  % 2. dli/dt
  % 3. dbetap/dt if constraints == 1, or dWth/dt if constraints == 2

elseif config.evolve_option == 2

  % The signals are:
  % current drive density * resistivity [V]
  % Values are given versus rhot.
  % This vector can be any length when gsevolve is used by itself
  % but when used in the gsevolve module, the number of points 
  % in this vector must be specified with field 'ncd', example:
  config.ncd = 65;

elseif config.evolve_option == 1
  
  % There are three signals in this line:
  % 1. dIp/dt
  % 2. dli/dt
  % 3. dbetap/dt if constraints == 1, or dWth/dt if constraints == 2

end



% STEP 4: OUTPUTS

% The output from gsevolve is a vector called 'y'
% The default content of this vector is psizr(:)
% Other content can be configured with the field 'outputs':

config.outputs = char('ic','fl','bp','rog','lv','rcur','zcur','cpasma');

% Complete list of possible outputs:

%           psizr: 'Poloidal flux on the grid'
%              ic: 'Coil currents, such that psizr_app = mpc*ic'
%              iv: 'Vessel currents, such that psizr_app = mpv*iv'
%              sp: 
% sp(1:nkn) are values for pres at psikn(1:nkn)
% sp(nkn+1) is pprime(end)*(psibry-psimag)/(2*pi)
% sp(nkn+2) is pbis(end)*(psibry-psimag)^2/(2*pi)^2
%              sf: 
% sf(1:nkn) are values for fpol^2/2-(rzero*bzero)^2/2 at psikn(1:nkn)
% sf(nkn+1) is ffprim(end)*(psibry-psimag)/(2*pi)
% sf(nkn+2) is (fpol(end)*fbis(end)+ffprim(end)^2)*(psibry-psimag)^2/(2*pi)^2
%              er: 
% Remaining fraction of flux error. 
% The flux error is found by gs_eq_analysis and can be subtracted 
% *after invoking gs_response* with: psizr(:) = psizr(:) - dpsizrdx(:,nx)*er
%              fl: 'Flux loop signals as defined by config fields mlc, mlv, mpl'
%              lv: 'Loop voltage signals as defined by config fields mhc, mhv, mph'
%              bp: 'Magnetic probe signals as defined by config fields gbc, gbv, gpb'
%             rog: 'Rogowski signals as defined by config field rldata'
%           psidp: 'Flux at diagnostic points rdp, zdp'
%            brdp: 'Radial magnetic field at diagnostic points rdp, zdp'
%            bzdp: 'Vertical magnetic field at diagnostic points rdp, zdp'
%            btdp: 'Toroidal magnetic field at diagnostic points rdp, zdp'
%           gapdp: 'Distance from rdp, zdp to boundary in direction toward axis';
%        gapdpdot: 'Boundary speed toward axis along gapdp vector';
%       gapdpdotA: 'Boundary speed toward axis when vps, vcd = 0';
%       gapdpdotB: 'Boundary speed toward axis caused by vps, vcd';
%      dgapdpdvps: 'd(gapdp)/dt = reshape(dgapdpdvps,ndp,nps)*vps';
%            gaps: 'Gaps from r,z along gr,gz to separatrix, gapspec=[r,z,gr,gz]';
%              ys: 'Flux at all conductors'
%              rx: 'Radii for x-points inside limiter
%              zx: 'Height for x-points inside limiter
%            psix: 'Flux at x-points inside limiter
%            rcur: 'Radius of current centroid'
%            zcur: 'Height of current centroid'
%          cpasma: 'Total toroidal plasma current'
%           nbbbs: 'number of valid points in rbbbs and zbbbs'
%           rbbbs: 'Radius of boundary points'
%           zbbbs: 'Height of boundary points'
%          rmaxis: 'Radius of magnetic axis'
%          zmaxis: 'Height of magnetic axis'
%          psimag: 'Flux at magnetic axis'
%           rbdef: 'Radius of point that defines the boundary'
%           zbdef: 'Height of point that defines the boundary'
%          psibry: 'Flux at boundary'
%              li: 'Normalized inductance'
%           betap: 'Poloidal beta'
%             Wth: 'Thermal energy'
%          psipla: 'Plasma flux'
%          bp2flx: '(mu0*cpasma/Cl)^2';
%       psiplaapp: 'Plasma flux from conductors';
%           vplas: 'Plasma voltage from conductors';
%            Lpla: 'Plasma self inductance';
%           lconn: 'Representative connection length';
%            Ltot: 'Area-integral of 1/R';
%            Atot: 'Area of plasma cross section';
%            Vtot: 'Total plasma volume';
%            rhot: 'square root of normalized toroidal flux';
%            jtav: 'Flux-surface averaged toroidal current density profile';
%            Vres: 'Resistive voltage profile';
%       fluxerror: 'Error in normalized flux, < 1e-2 for valid GS solutions
%            time: 'Simulation time (used for plots and time-dependent config data)
%           gamma: 'Growth rate of most unstable mode'
%        drcurdv1: 'Response of rcur to most unstable eigen vector'
%        dzcurdv1: 'Response of zcur to most unstable eigen vector'
%  response_count: 'Number of calls to gs_response or gscp_analysis_response'
%              19: 'a number inserts that number zero-signals, here 19'
%    user_defined: 'Signals defined by the user (more on that under step 6)'

% The number of x-points in the output vector, y is controlled by 'nxpoints'
% config.nxpoints = 2; % The default value is 2
% The method for sorting the x-points is specified with 'xpointorder', options are:
% 1 = sort x-points w.r.t. normalized poloidal flux (default)
% 2 = sort x-points w.r.t. their z coordinate
% 3 = sort x-points w.r.t. normalized poloidal flux initially, then track the points
% 4 = sort x-points w.r.t. their z coordinates initially, then track the points
% With option 3 an x-point won't change its place in y if its normalized flux
% changes past the flux at other x-points
% With option 4 an x-point won't change its place in y if its z coordinate
% changes past that of another x-point (at another radius)
% Not all of these options are yet implemented
config.xpointorder = 1;
% x-points outside the limiter are ignored
% If there are fewer x-points than requested with nxpoints, remaining entries in y will
% contain zeros. Validity of an x-point can be checked by testing that rx is nonzero.

% The diagnostic points (dp) are specified with fields 'rdp', 'zdp', example:
config.rdp = [1.7 2.3];
config.zdp = [0.0 0.0];
% Flux and field components at these points as well as "gapdp" 
% can be extracted, as listed above
% Note that gapdp has a different definition than "gaps"
% since the direction of a gapdp measurement depends on the magnetic axis

if 0
% The following example shows how to create a user-defined signal
% The signal will be given the arbitrary name 'mysig' and size 3
nc = config.nc;
nv = config.nv;
ngg = config.nr*config.nz;
config.mysig0 = rand(3,1); % 1 signal per row, these are the baseline values
config.dmysigdic = rand(3,nc); % How signals scale with coil currents, ic
config.dmysigdiv = rand(3,nv); % How signals scale with vessel currents, iv
config.dmysigdpcurrt = rand(3,ngg); % How signals scale with current in grid cells
% In a real case there would of course be meaningful numbers instead of random
% It only takes one of these fields to create the signal, all others will default to zero
% The signal is calculated by the formula:
% mysig = mysig0 + dmysigdic*ic + dmysigdiv*iv + dmysigdpcurrt*pcurrt(:)
% In order to extract this signal, add it to the outputs:
config.outputs = char(config.outputs,'mysig');
% Define a second signal
config.newspecial0 = [2; 1; 4; 4; 5];
config.outputs = char(config.outputs,'newspecial');
% Any number of these signals can be defined. After gsevolve has been configured they
% will appear in index_in_y as index_in_y.mysig, etc. This can be verified by typing:
gsevolve index_in_y
end

% CONTINUITY OF CONTINUOUS OUTPUTS
% When the equilibrium has changed by an appreciable amount since previous
% analysis, gsevolve makes a new analysis and update of the plasma response
% This will cause a mismatch between calculations of outputs, y
% made with the previous analysis and the new
% The new linear calculation can be gradually phased in with the switch
config.phaseouterrors = 1; % Default is 1
% If the change is larger than "appreciable" between calls,
% the new values of y will be sent out in full as if phaseouterrors = 0
% Phasing is only applied to continuous outputs that aren't responses
% "Appreciable" amount is defined by dpsibar_limit_for_linear, see STEP 6.

% STEP 5: PLOTTING DURING SIMULATIONS

% A very detailed plot can be produced by setting 'plotit'
% This plot contains coil currents, pprime, ffprim, flux error, 
% a list of scalar quantities and the boundary with flux contours
% The values of plotit can be:
% 0 = don't plot (default)
% 1 = plot once on every call (except when the linear response is used)
% 2 = also plot after every iteration when the equilibrium is converged
% 3 = also plot every iteration when boundary tracing becomes complicated

config.plotit = 0;


% Two criteria can be used to draw a fast simple plot of the plasma:
% It is possible to zoom in on different parts of the plasma
% during simulations and inspect them closely
% This simple plot is controlled by the three switches:

% Plot when the plasma response has been updated
config.plot_if_new_response = 0;

% Plot when times have been reached
%config.plot_times = 0:0.001:1;

% Plot at regular time intervals
config.dtplot = 1e-4;

% The appearance of simple plots is controlled by 'plot_settings'
% Content and appearance of the plot can be controlled in a lot of 
% detail if desired. Items are deselected by setting LineWidth = 0
% In this example all settings are the same as the defaults

% Boundary
plot_settings.boundary.LineWidth = 3;
plot_settings.boundary.Color = [0.56 0 1];
plot_settings.boundary.patch = false;
plot_settings.boundary.EdgeColor = [.8 .6 .1];
plot_settings.boundary.FaceColor = [1 1 .8];

% Boundary-defining point
plot_settings.bdef.LineWidth = 3;
plot_settings.bdef.Color = [1 .4 0];
plot_settings.bdef.Marker = 'x';
plot_settings.bdef.MarkerSize = 18;

% Touch point
plot_settings.touch.LineWidth = 3;
plot_settings.touch.Color = [1 .8 0];
plot_settings.touch.Marker = '*';
plot_settings.touch.MarkerSize = 24;

% Diagnostic points
plot_settings.dp.LineWidth = 0;
plot_settings.dp.Color = [0 1 0];
plot_settings.dp.Marker = 'x';
plot_settings.dp.MarkerSize = 10;

% Flux contours
plot_settings.flux_contours.psibar = [2 4 6 8]/10;
plot_settings.flux_contours.LineWidth = 3;
plot_settings.flux_contours.fill = false;

% Camera
plot_settings.camera.showit = 0; % 1 = show camera image of plasma
plot_settings.camera.animate = 1; % 0 = show still of initial plasma
plot_settings.camera.nxpix = 64; % pixels in the image
plot_settings.camera.nzpix = 128; % pixels in the image

% Limiter
if plot_settings.camera.showit
  plot_settings.limiter.LineWidth = 6;
else
  plot_settings.limiter.LineWidth = 3;
end
if plot_settings.camera.showit
  plot_settings.limiter.Color = [0 1 0];
else
  plot_settings.limiter.Color = [0.5, 0.5, 0.5];
end
plot_settings.limiter.patch = false;
plot_settings.limiter.EdgeColor = [0.5 0.5 0.5];
plot_settings.limiter.FaceColor = [0.7 0.7 0.7];
% Glow color is the brightest light seen by the camera when the wall
% glows because it is being heated by radiation from the plasma
plot_settings.limiter.GlowColor = [0.9 0.8 1.0];

% Vessel
plot_settings.vessel.LineWidth = 2;
plot_settings.vessel.Color = [.1 .1 .8];
plot_settings.vessel.patch = false;
plot_settings.vessel.EdgeColor = [0 1 1];
plot_settings.vessel.FaceColor = [0 0 1];

% Coils
plot_settings.coils.LineWidth = 3;
plot_settings.coils.Color = [1 .1 0];
plot_settings.coils.patch = false;
plot_settings.coils.EdgeColor = [0 1 1];
plot_settings.coils.FaceColor = [0 0 1];

% Text with information about Ip, li, betap, gamma
plot_settings.text.FontSize = 15;


% Put the plot settings into config (important step)
config.plot_settings = plot_settings;


% STEP 6: OTHER SETTINGS

% The field 'dpsibar_limit_for_linear' controls how much the normalized
% flux (psibar) can change in the plasma before the linear response
% is updated. Higher values mean faster execution but lower accuracy
% Recommended values are 1e-2 for fast to 1e-4 for accurate

config.dpsibar_limit_for_linear = 2e-3;
% Tip: you can pause simulation and change value, example:
% gsevolve('dpsibar_limit_for_linear',5e-3) % Speed up a bit compared to 2e-3

% The equilibrium can be converged on every call by setting flag 'converge'
% This is roughly equivalent to dpsibar_limit_for_linear = 0
config.converge = false; % default is false
% This setting can be overriden by supplying converge in the input 'u'
% u.converge = true;


% The pressure and current profiles are spline functions in gsevolve
% The knots are at normalized flux vales given in 'psikn'

config.psikn = [0 0.25 0.50 0.75 1]; % default is [0 1]

% Between the knots the profiles are 3:rd degree polynomials in psibar
% At the knots the values and first and second derivatives are continuous
% The values in psikn should range from 0 to 1


if config.evolve_option == 1

  % When the plasma profiles are described by only the 3 numbers:
  % 1. cpasma, 2. li, 3. betap,
  % the details of the profiles are copied from an initial equilibrium
  % if one is supplied or else set constant as function of flux
  
  % In this mode, the current at the edge can be forced to zero:
  
  config.no_edge_current = false; % default for this is false
  
  % The gradient at the edge can also be forced to zero
  
  config.no_edge_gradient = false; % default for this is false
  
  % Note that if both of these are set to true then psikn must contain
  % at least 3 values (at least one value between 0 and 1)
  % Otherwise there will only be 2 degrees of freedom for making the 3 numbers

end


% The field 'gas' is used to simulate breakdown. The value represents available
% particles for plasma. At present this value is used as a boolean.
config.gas = 1; % default is 1
% The value can be overriden by setting 
% u.gas = 0;
% The value of gas will be:
% u.gas if it exists, or else:
% config.gas if it has ever been specified, or else:
% 1 (the default)








